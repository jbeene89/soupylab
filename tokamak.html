<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tokamak Reactor 3D - Soupy Labs</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg: #0a0a0f;
            --panel: #12121a;
            --accent: #00aaff;
            --text: #e0e0e0;
            --dim: #606080;
        }
        body { font-family: 'Segoe UI', sans-serif; background: var(--bg); color: var(--text); overflow: hidden; }
        header {
            background: linear-gradient(180deg, rgba(0,170,255,0.1) 0%, transparent 100%);
            border-bottom: 1px solid rgba(0,170,255,0.2);
            padding: 12px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
            z-index: 100;
        }
        header h1 { font-size: 1.2rem; color: var(--accent); }
        header a { color: #00ff9d; text-decoration: none; padding: 6px 12px; border: 1px solid rgba(0,255,157,0.3); border-radius: 4px; font-size: 0.8rem; }

        .main-container {
            display: grid;
            grid-template-columns: 300px 1fr 350px;
            height: calc(100vh - 56px);
        }

        .controls {
            background: var(--panel);
            padding: 16px;
            overflow-y: auto;
            border-right: 1px solid rgba(255,255,255,0.05);
        }
        .section { margin-bottom: 20px; }
        .section h3 {
            font-size: 0.75rem;
            color: var(--accent);
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(0,170,255,0.2);
            padding-bottom: 6px;
        }

        .param-group select {
            width: 100%;
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
            color: var(--text);
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 12px;
            font-size: 0.75rem;
        }

        .slider-row { margin-bottom: 14px; }
        .slider-row label {
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            color: var(--dim);
            margin-bottom: 4px;
        }
        .slider-row label span { color: var(--accent); font-family: monospace; }
        .slider-input-row {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        .slider-input-row input[type="range"] {
            flex: 1;
            height: 4px;
            -webkit-appearance: none;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
        }
        .slider-input-row input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px; height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
        }
        .slider-input-row input[type="number"] {
            width: 60px;
            background: rgba(0,0,0,0.4);
            border: 1px solid rgba(255,255,255,0.15);
            color: var(--accent);
            padding: 4px 6px;
            border-radius: 4px;
            font-size: 0.7rem;
            font-family: monospace;
            text-align: right;
        }

        .hidden { display: none !important; }

        .viewport {
            position: relative;
            background: #000;
        }
        #viewport3D {
            width: 100%;
            height: 100%;
        }
        .view-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 5px;
            z-index: 10;
        }
        .view-controls button {
            padding: 6px 12px;
            background: rgba(0,170,255,0.2);
            border: 1px solid var(--accent);
            color: var(--accent);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.7rem;
            transition: all 0.3s;
        }
        .view-controls button:hover {
            background: rgba(0,170,255,0.4);
        }

        .stats-panel {
            background: var(--panel);
            padding: 16px;
            overflow-y: auto;
            border-left: 1px solid rgba(255,255,255,0.05);
        }
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 16px;
        }
        .stat-box {
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 6px;
            padding: 10px;
        }
        .stat-box .label {
            font-size: 0.65rem;
            color: var(--dim);
            margin-bottom: 4px;
        }
        .stat-box .value {
            font-size: 1.1rem;
            color: var(--accent);
            font-family: monospace;
            font-weight: bold;
        }
        .stat-box.good { border-color: #00ff9d; }
        .stat-box.good .value { color: #00ff9d; }
        .stat-box.warn { border-color: #ffcc00; }
        .stat-box.warn .value { color: #ffcc00; }
        .stat-box.bad { border-color: #ff4444; }
        .stat-box.bad .value { color: #ff4444; }

        .info-section {
            background: rgba(0,170,255,0.05);
            border: 1px solid rgba(0,170,255,0.2);
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 16px;
        }
        .info-section h3 {
            font-size: 0.75rem;
            color: var(--accent);
            margin-bottom: 8px;
        }
        .info-section div {
            font-size: 0.65rem;
            color: var(--dim);
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <header>
        <h1>üîµ TOKAMAK REACTOR 3D</h1>
        <a href="index.html">‚Üê Back</a>
    </header>

    <div class="main-container">
        <!-- Controls -->
        <div class="controls">
            <div class="section">
                <h3>PARAMETER GROUP</h3>
                <div class="param-group">
                    <select id="paramGroup" onchange="updateParamGroup()">
                        <option value="geometry">Geometry</option>
                        <option value="plasma">Plasma</option>
                        <option value="heating">Heating & Current</option>
                        <option value="performance">Performance</option>
                    </select>
                </div>
            </div>

            <div id="geometry-params" class="param-set">
                <div class="slider-row">
                    <label><span>Major Radius R‚ÇÄ</span><span id="R0_lbl">6.2 m</span></label>
                    <div class="slider-input-row">
                        <input type="range" id="R0" min="2" max="15" step="0.1" value="6.2" oninput="syncFromSlider('R0')">
                        <input type="number" id="R0_num" value="6.2" step="0.1" onchange="syncFromNumber('R0')">
                    </div>
                </div>
                <div class="slider-row">
                    <label><span>Minor Radius a</span><span id="a_lbl">2.0 m</span></label>
                    <div class="slider-input-row">
                        <input type="range" id="a" min="0.5" max="5" step="0.1" value="2.0" oninput="syncFromSlider('a')">
                        <input type="number" id="a_num" value="2.0" step="0.1" onchange="syncFromNumber('a')">
                    </div>
                </div>
                <div class="slider-row">
                    <label><span>Elongation Œ∫</span><span id="kappa_lbl">1.7</span></label>
                    <div class="slider-input-row">
                        <input type="range" id="kappa" min="1" max="2.5" step="0.1" value="1.7" oninput="syncFromSlider('kappa')">
                        <input type="number" id="kappa_num" value="1.7" step="0.1" onchange="syncFromNumber('kappa')">
                    </div>
                </div>
                <div class="slider-row">
                    <label><span>Triangularity Œ¥</span><span id="delta_lbl">0.33</span></label>
                    <div class="slider-input-row">
                        <input type="range" id="delta" min="0" max="0.8" step="0.01" value="0.33" oninput="syncFromSlider('delta')">
                        <input type="number" id="delta_num" value="0.33" step="0.01" onchange="syncFromNumber('delta')">
                    </div>
                </div>
            </div>

            <div id="plasma-params" class="param-set hidden">
                <div class="slider-row">
                    <label><span>Density nÃÑ (10¬≤‚Å∞/m¬≥)</span><span id="n_lbl">1.0</span></label>
                    <div class="slider-input-row">
                        <input type="range" id="n" min="0.1" max="5" step="0.1" value="1.0" oninput="syncFromSlider('n')">
                        <input type="number" id="n_num" value="1.0" step="0.1" onchange="syncFromNumber('n')">
                    </div>
                </div>
                <div class="slider-row">
                    <label><span>Temperature TÃÑ (keV)</span><span id="T_lbl">15</span></label>
                    <div class="slider-input-row">
                        <input type="range" id="T" min="1" max="40" step="1" value="15" oninput="syncFromSlider('T')">
                        <input type="number" id="T_num" value="15" step="1" onchange="syncFromNumber('T')">
                    </div>
                </div>
                <div class="slider-row">
                    <label><span>Plasma Current I_p (MA)</span><span id="Ip_lbl">15</span></label>
                    <div class="slider-input-row">
                        <input type="range" id="Ip" min="1" max="25" step="0.5" value="15" oninput="syncFromSlider('Ip')">
                        <input type="number" id="Ip_num" value="15" step="0.5" onchange="syncFromNumber('Ip')">
                    </div>
                </div>
                <div class="slider-row">
                    <label><span>Toroidal Field B_T (T)</span><span id="BT_lbl">5.3</span></label>
                    <div class="slider-input-row">
                        <input type="range" id="BT" min="1" max="15" step="0.1" value="5.3" oninput="syncFromSlider('BT')">
                        <input type="number" id="BT_num" value="5.3" step="0.1" onchange="syncFromNumber('BT')">
                    </div>
                </div>
            </div>

            <div id="heating-params" class="param-set hidden">
                <div class="slider-row">
                    <label><span>NBI Power (MW)</span><span id="NBI_lbl">33</span></label>
                    <div class="slider-input-row">
                        <input type="range" id="NBI" min="0" max="100" step="1" value="33" oninput="syncFromSlider('NBI')">
                        <input type="number" id="NBI_num" value="33" step="1" onchange="syncFromNumber('NBI')">
                    </div>
                </div>
                <div class="slider-row">
                    <label><span>ICRH Power (MW)</span><span id="ICRH_lbl">20</span></label>
                    <div class="slider-input-row">
                        <input type="range" id="ICRH" min="0" max="80" step="1" value="20" oninput="syncFromSlider('ICRH')">
                        <input type="number" id="ICRH_num" value="20" step="1" onchange="syncFromNumber('ICRH')">
                    </div>
                </div>
                <div class="slider-row">
                    <label><span>ECRH Power (MW)</span><span id="ECRH_lbl">20</span></label>
                    <div class="slider-input-row">
                        <input type="range" id="ECRH" min="0" max="80" step="1" value="20" oninput="syncFromSlider('ECRH')">
                        <input type="number" id="ECRH_num" value="20" step="1" onchange="syncFromNumber('ECRH')">
                    </div>
                </div>
            </div>

            <div id="performance-params" class="param-set hidden">
                <div class="slider-row">
                    <label><span>H-factor</span><span id="H_lbl">1.0</span></label>
                    <div class="slider-input-row">
                        <input type="range" id="H" min="0.5" max="2.0" step="0.05" value="1.0" oninput="syncFromSlider('H')">
                        <input type="number" id="H_num" value="1.0" step="0.05" onchange="syncFromNumber('H')">
                    </div>
                </div>
                <div class="slider-row">
                    <label><span>Z_eff</span><span id="Zeff_lbl">1.5</span></label>
                    <div class="slider-input-row">
                        <input type="range" id="Zeff" min="1" max="4" step="0.1" value="1.5" oninput="syncFromSlider('Zeff')">
                        <input type="number" id="Zeff_num" value="1.5" step="0.1" onchange="syncFromNumber('Zeff')">
                    </div>
                </div>
                <div class="slider-row">
                    <label><span>Œ≤_N</span><span id="betaN_lbl">2.0</span></label>
                    <div class="slider-input-row">
                        <input type="range" id="betaN" min="0.5" max="4" step="0.1" value="2.0" oninput="syncFromSlider('betaN')">
                        <input type="number" id="betaN_num" value="2.0" step="0.1" onchange="syncFromNumber('betaN')">
                    </div>
                </div>
                <div class="slider-row">
                    <label><span>q‚Çâ‚ÇÖ</span><span id="q95_lbl">3.0</span></label>
                    <div class="slider-input-row">
                        <input type="range" id="q95" min="2" max="8" step="0.1" value="3.0" oninput="syncFromSlider('q95')">
                        <input type="number" id="q95_num" value="3.0" step="0.1" onchange="syncFromNumber('q95')">
                    </div>
                </div>
            </div>

            <div class="section">
                <h3>QUALITY MODE</h3>
                <div class="param-group">
                    <select id="qualityMode" onchange="applyQualityMode(this.value)">
                        <option value="visual">Visual Heavy (Better Graphics)</option>
                        <option value="balanced" selected>Balanced</option>
                        <option value="physics">Physics Accurate (Precise)</option>
                    </select>
                </div>
            </div>

            <div class="section">
                <h3>GRAPHICS</h3>
                <div class="slider-row">
                    <label><span>Bloom Intensity</span><span id="bloom_lbl">1.5</span></label>
                    <div class="slider-input-row">
                        <input type="range" id="bloom" min="0" max="5" step="0.1" value="1.5" oninput="syncFromSlider('bloom')">
                        <input type="number" id="bloom_num" value="1.5" step="0.1" onchange="syncFromNumber('bloom')">
                    </div>
                </div>
                <div class="slider-row">
                    <label><span>Particle Glow</span><span id="glow_lbl">0.8</span></label>
                    <div class="slider-input-row">
                        <input type="range" id="glow" min="0" max="2" step="0.1" value="0.8" oninput="syncFromSlider('glow')">
                        <input type="number" id="glow_num" value="0.8" step="0.1" onchange="syncFromNumber('glow')">
                    </div>
                </div>
            </div>
        </div>

        <!-- 3D Viewport -->
        <div class="viewport">
            <div id="viewport3D"></div>
            <div class="view-controls">
                <button onclick="setView('perspective')">Perspective</button>
                <button onclick="setView('top')">Top</button>
                <button onclick="setView('side')">Side</button>
                <button onclick="setView('cross')">Cross-Section</button>
            </div>
        </div>

        <!-- Stats Panel -->
        <div class="stats-panel">
            <div class="section">
                <h3>PERFORMANCE METRICS</h3>
                <div class="stats-grid">
                    <div class="stat-box" id="lawsonBox">
                        <div class="label">Lawson Criterion</div>
                        <div class="value" id="lawson">‚Äî</div>
                    </div>
                    <div class="stat-box" id="qBox">
                        <div class="label">Q Factor</div>
                        <div class="value" id="qfactor">‚Äî</div>
                    </div>
                    <div class="stat-box">
                        <div class="label">Confinement œÑ_E</div>
                        <div class="value" id="tau">‚Äî</div>
                    </div>
                    <div class="stat-box">
                        <div class="label">Fusion Power</div>
                        <div class="value" id="pfus">‚Äî</div>
                    </div>
                    <div class="stat-box">
                        <div class="label">Aspect Ratio</div>
                        <div class="value" id="aspect">‚Äî</div>
                    </div>
                    <div class="stat-box">
                        <div class="label">Plasma Volume</div>
                        <div class="value" id="volume">‚Äî</div>
                    </div>
                </div>
            </div>

            <div class="info-section">
                <h3>ABOUT TOKAMAKS</h3>
                <div>
                    Tokamaks use a <strong>plasma current</strong> to create the poloidal field needed for rotational transform.
                    This enables simpler coil geometry than stellarators, but introduces disruption risk when q < 2
                    (Kruskal-Shafranov limit). ITER uses this design.
                </div>
            </div>

            <div class="info-section">
                <h3>CURRENT DESIGN</h3>
                <div>
                    <strong>Type:</strong> ITER-like D-shaped<br>
                    <strong>Confinement:</strong> IPB98(y,2) scaling<br>
                    <strong>Divertor:</strong> X-point configuration<br>
                    <strong>Heating:</strong> NBI + ICRH + ECRH
                </div>
            </div>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // ===== THREE.JS 3D TOKAMAK =====
        let scene, camera, renderer, composer, bloomPass;
        let plasmaTorus, tfCoils = [], pfCoils = [];
        let particleSystem, fieldLines = [];
        let viewMode = 'perspective';
        let animationTime = 0;

        const params = {
            R0: 6.2, a: 2.0, kappa: 1.7, delta: 0.33,
            n: 1.0, T: 15, Ip: 15, Zeff: 1.5,
            BT: 5.3, q95: 3.0, betaN: 2.0,
            NBI: 33, ICRH: 20, ECRH: 20,
            H: 1.0,
            bloom: 1.5,
            glow: 0.8
        };

        function initThreeJS() {
            const container = document.getElementById('viewport3D');

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            scene.fog = new THREE.Fog(0x000000, 20, 100);

            // Camera
            camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 200);
            camera.position.set(25, 15, 25);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            // Post-processing
            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
            bloomPass = new UnrealBloomPass(
                new THREE.Vector2(container.clientWidth, container.clientHeight),
                1.5, 0.4, 0.85
            );
            composer.addPass(bloomPass);

            // Lights
            const ambientLight = new THREE.AmbientLight(0x222244, 0.5);
            scene.add(ambientLight);

            const pointLight1 = new THREE.PointLight(0x00aaff, 1, 100);
            pointLight1.position.set(20, 20, 20);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0xff6600, 0.5, 100);
            pointLight2.position.set(-20, 10, -20);
            scene.add(pointLight2);

            // Create tokamak components
            createPlasma();
            createTFCoils();
            createPFCoils();
            createParticles();
            createFieldLines();

            // Grid
            const gridHelper = new THREE.GridHelper(40, 40, 0x00aaff, 0x222244);
            gridHelper.position.y = -10;
            scene.add(gridHelper);

            window.addEventListener('resize', onWindowResize);
        }

        function createPlasma() {
            // Create D-shaped torus for plasma
            const segments = 64;
            const geometry = new THREE.TorusGeometry(params.R0, params.a, segments, segments);

            // Modify geometry for D-shape and elongation
            const positions = geometry.attributes.position;
            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const y = positions.getY(i);
                const z = positions.getZ(i);

                // Calculate poloidal angle
                const r = Math.sqrt(x*x + z*z) - params.R0;
                const theta = Math.atan2(z, x - params.R0);

                // Apply D-shaping (triangularity)
                const deltaR = params.delta * params.a * Math.cos(theta);
                const newR = Math.sqrt(x*x + z*z) + deltaR;
                const angle = Math.atan2(z, x);

                positions.setX(i, newR * Math.cos(angle));
                positions.setZ(i, newR * Math.sin(angle));

                // Apply elongation
                positions.setY(i, y * params.kappa);
            }
            geometry.attributes.position.needsUpdate = true;
            geometry.computeVertexNormals();

            // Plasma material with temperature gradient
            const material = new THREE.MeshPhongMaterial({
                color: 0xff6600,
                emissive: 0xff3300,
                emissiveIntensity: 0.8,
                transparent: true,
                opacity: 0.6,
                side: THREE.DoubleSide
            });

            plasmaTorus = new THREE.Mesh(geometry, material);
            scene.add(plasmaTorus);
        }

        function createTFCoils() {
            // Create 18 toroidal field coils
            const numCoils = 18;
            const coilRadius = params.R0 + params.a * 1.5;

            for (let i = 0; i < numCoils; i++) {
                const angle = (i / numCoils) * Math.PI * 2;

                // D-shaped coil
                const shape = new THREE.Shape();
                const coilA = params.a * 1.4;
                for (let theta = 0; theta <= Math.PI * 2; theta += 0.1) {
                    const r = coilA * (1 + 0.3 * Math.cos(theta));
                    const x = r * Math.cos(theta);
                    const y = r * Math.sin(theta) * 1.8;
                    if (theta === 0) shape.moveTo(x, y);
                    else shape.lineTo(x, y);
                }

                const extrudeSettings = {
                    steps: 1,
                    depth: 0.3,
                    bevelEnabled: true,
                    bevelThickness: 0.05,
                    bevelSize: 0.05,
                    bevelSegments: 3
                };

                const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
                const material = new THREE.MeshStandardMaterial({
                    color: 0x4488ff,
                    metalness: 0.8,
                    roughness: 0.2,
                    emissive: 0x0044aa,
                    emissiveIntensity: 0.2
                });

                const coil = new THREE.Mesh(geometry, material);
                coil.position.x = params.R0 * Math.cos(angle);
                coil.position.z = params.R0 * Math.sin(angle);
                coil.rotation.y = angle;
                coil.castShadow = true;

                scene.add(coil);
                tfCoils.push(coil);
            }
        }

        function createPFCoils() {
            // Poloidal field coils (simplified)
            const coilPositions = [
                [0, 8, 0],
                [0, -8, 0],
                [params.R0 + 5, 0, 0],
                [-(params.R0 + 5), 0, 0]
            ];

            coilPositions.forEach(pos => {
                const geometry = new THREE.TorusGeometry(1.5, 0.3, 16, 32);
                const material = new THREE.MeshStandardMaterial({
                    color: 0x00ff88,
                    metalness: 0.7,
                    roughness: 0.3,
                    emissive: 0x00aa44,
                    emissiveIntensity: 0.3
                });

                const coil = new THREE.Mesh(geometry, material);
                coil.position.set(pos[0], pos[1], pos[2]);
                if (pos[0] !== 0) coil.rotation.z = Math.PI / 2;
                coil.castShadow = true;

                scene.add(coil);
                pfCoils.push(coil);
            });
        }

        function createParticles() {
            const geometry = new THREE.BufferGeometry();
            const particles = 3000;
            const positions = new Float32Array(particles * 3);
            const colors = new Float32Array(particles * 3);

            for (let i = 0; i < particles; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI * 2;
                const r = params.R0 + (Math.random() - 0.5) * params.a * 0.8;

                positions[i * 3] = r * Math.cos(theta);
                positions[i * 3 + 1] = (Math.random() - 0.5) * params.a * params.kappa;
                positions[i * 3 + 2] = r * Math.sin(theta);

                // Color based on temperature
                const temp = Math.random();
                colors[i * 3] = 1;
                colors[i * 3 + 1] = 0.5 + temp * 0.5;
                colors[i * 3 + 2] = temp * 0.5;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.15,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });

            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
        }

        function createFieldLines() {
            // Magnetic field lines (helical)
            for (let i = 0; i < 8; i++) {
                const points = [];
                const startAngle = i * Math.PI / 4;

                for (let t = 0; t < Math.PI * 20; t += 0.1) {
                    const r = params.R0 + params.a * 0.7 * Math.cos(t / 5);
                    const theta = startAngle + t;
                    const y = params.a * 0.7 * Math.sin(t / 5) * params.kappa;

                    points.push(new THREE.Vector3(
                        r * Math.cos(theta),
                        y,
                        r * Math.sin(theta)
                    ));
                }

                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.3
                });

                const line = new THREE.Line(geometry, material);
                scene.add(line);
                fieldLines.push(line);
            }
        }

        function updateGeometry() {
            // Remove old plasma
            scene.remove(plasmaTorus);

            // Recreate with new parameters
            createPlasma();

            // Update TF coils
            tfCoils.forEach((coil, i) => {
                const angle = (i / tfCoils.length) * Math.PI * 2;
                coil.position.x = params.R0 * Math.cos(angle);
                coil.position.z = params.R0 * Math.sin(angle);
            });
        }

        function updateParticles() {
            const positions = particleSystem.geometry.attributes.position.array;
            const colors = particleSystem.geometry.attributes.color.array;

            for (let i = 0; i < positions.length / 3; i++) {
                const theta = animationTime * 0.5 + i * 0.01;
                const r = params.R0 + (Math.sin(i * 0.1 + animationTime) * 0.5) * params.a * 0.8;

                positions[i * 3] = r * Math.cos(theta);
                positions[i * 3 + 2] = r * Math.sin(theta);

                // Pulsing glow based on temperature
                const glow = 0.5 + 0.5 * Math.sin(animationTime * 2 + i * 0.05);
                colors[i * 3 + 1] = 0.5 + glow * 0.5;
            }

            particleSystem.geometry.attributes.position.needsUpdate = true;
            particleSystem.geometry.attributes.color.needsUpdate = true;
        }

        function setView(mode) {
            viewMode = mode;
            switch(mode) {
                case 'perspective':
                    camera.position.set(25, 15, 25);
                    camera.lookAt(0, 0, 0);
                    break;
                case 'top':
                    camera.position.set(0, 30, 0);
                    camera.lookAt(0, 0, 0);
                    break;
                case 'side':
                    camera.position.set(params.R0 * 3, 0, 0);
                    camera.lookAt(0, 0, 0);
                    break;
                case 'cross':
                    camera.position.set(0, 0, 25);
                    camera.lookAt(0, 0, 0);
                    break;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            animationTime += 0.01;

            // Rotate plasma slowly
            if (plasmaTorus) {
                plasmaTorus.rotation.y += 0.002;
            }

            // Animate particles
            updateParticles();

            // Rotate field lines
            fieldLines.forEach(line => {
                line.rotation.y += 0.001;
            });

            composer.render();
        }

        function onWindowResize() {
            const container = document.getElementById('viewport3D');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
            composer.setSize(container.clientWidth, container.clientHeight);
        }

        // ===== PHYSICS CALCULATIONS =====
        function update() {
            // Read all parameters
            Object.keys(params).forEach(key => {
                const el = document.getElementById(key);
                if (el) {
                    params[key] = parseFloat(el.value);
                    const lbl = document.getElementById(key + '_lbl');
                    if (lbl) lbl.textContent = el.value;
                }
            });

            // Update 3D geometry
            updateGeometry();

            // Calculate derived quantities
            const aspect = params.R0 / params.a;
            const volume = 2 * Math.PI * Math.PI * params.R0 * params.a * params.a * params.kappa;
            const Pheat = params.NBI + params.ICRH + params.ECRH;

            // ITER IPB98(y,2) scaling
            const tau = 0.145 * params.H * Math.pow(params.Ip, 0.93) * Math.pow(params.BT, 0.15) *
                       Math.pow(params.n * 0.1, 0.41) * Math.pow(Math.max(1, Pheat), -0.69) *
                       Math.pow(params.R0, 1.97) * Math.pow(params.a / params.R0, 0.58) *
                       Math.pow(params.kappa, 0.78);

            const lawson = params.n * 1e20 * tau * params.T * 1000;
            const Pfus = 0.00017 * params.n * params.n * Math.pow(params.T, 2) * volume * Math.exp(-20/params.T);
            const Q = Pfus / Math.max(1, Pheat);

            // Update display
            document.getElementById('aspect').textContent = aspect.toFixed(1);
            document.getElementById('volume').textContent = volume.toFixed(0) + ' m¬≥';
            document.getElementById('tau').textContent = tau.toFixed(2) + ' s';
            document.getElementById('lawson').textContent = (lawson / 1e21).toFixed(1) + '√ó10¬≤¬π';
            document.getElementById('pfus').textContent = Pfus.toFixed(0) + ' MW';
            document.getElementById('qfactor').textContent = Q.toFixed(1);

            // Color coding
            document.getElementById('lawsonBox').className = 'stat-box ' + (lawson > 3e21 ? 'good' : lawson > 1e21 ? 'warn' : 'bad');
            document.getElementById('qBox').className = 'stat-box ' + (Q > 5 ? 'good' : Q > 1 ? 'warn' : 'bad');

            // Update plasma color based on temperature
            if (plasmaTorus) {
                const tempFactor = Math.min(params.T / 40, 1);
                const r = 255;
                const g = Math.floor(102 + tempFactor * 153);
                const b = Math.floor(tempFactor * 255);
                plasmaTorus.material.color.setRGB(r/255, g/255, b/255);
                plasmaTorus.material.emissive.setRGB(r/255 * 0.8, g/255 * 0.3, 0);
            }
        }

        // Quality Mode System
        function applyQualityMode(mode) {
            if (mode === 'visual') {
                // Visual Heavy Mode: Better graphics, simplified physics
                bloomPass.strength = 3.0;
                particleSystem.material.size = 0.25;

                // Update UI displays
                document.getElementById('bloom_lbl').textContent = '3.0';
                document.getElementById('bloom').value = 3.0;
                document.getElementById('bloom_num').value = 3.0;
                document.getElementById('glow_lbl').textContent = '1.5';
                document.getElementById('glow').value = 1.5;
                document.getElementById('glow_num').value = 1.5;

            } else if (mode === 'physics') {
                // Physics Accurate Mode: Precise visuals
                bloomPass.strength = 0.8;
                particleSystem.material.size = 0.10;

                // Update UI displays
                document.getElementById('bloom_lbl').textContent = '0.8';
                document.getElementById('bloom').value = 0.8;
                document.getElementById('bloom_num').value = 0.8;
                document.getElementById('glow_lbl').textContent = '0.5';
                document.getElementById('glow').value = 0.5;
                document.getElementById('glow_num').value = 0.5;

            } else {
                // Balanced Mode: Default values
                bloomPass.strength = 1.5;
                particleSystem.material.size = 0.15;

                // Update UI displays
                document.getElementById('bloom_lbl').textContent = '1.5';
                document.getElementById('bloom').value = 1.5;
                document.getElementById('bloom_num').value = 1.5;
                document.getElementById('glow_lbl').textContent = '0.8';
                document.getElementById('glow').value = 0.8;
                document.getElementById('glow_num').value = 0.8;
            }

            // Update plasma glow based on glow setting
            const glowIntensity = parseFloat(document.getElementById('glow').value);
            if (plasmaTorus) {
                plasmaTorus.material.emissiveIntensity = glowIntensity;
            }
        }

        function updateParamGroup() {
            const group = document.getElementById('paramGroup').value;
            document.querySelectorAll('.param-set').forEach(el => el.classList.add('hidden'));
            document.getElementById(group + '-params').classList.remove('hidden');
        }

        function syncFromSlider(id) {
            const slider = document.getElementById(id);
            const numInput = document.getElementById(id + '_num');
            if (numInput) numInput.value = slider.value;

            // Handle graphics parameters directly
            if (id === 'bloom') {
                bloomPass.strength = parseFloat(slider.value);
            } else if (id === 'glow') {
                if (plasmaTorus) {
                    plasmaTorus.material.emissiveIntensity = parseFloat(slider.value);
                }
            }

            update();
        }

        function syncFromNumber(id) {
            const numInput = document.getElementById(id + '_num');
            const slider = document.getElementById(id);
            if (slider) {
                let val = parseFloat(numInput.value);
                val = Math.max(parseFloat(slider.min), Math.min(parseFloat(slider.max), val));
                slider.value = val;
                numInput.value = val;

                // Handle graphics parameters directly
                if (id === 'bloom') {
                    bloomPass.strength = val;
                } else if (id === 'glow') {
                    if (plasmaTorus) {
                        plasmaTorus.material.emissiveIntensity = val;
                    }
                }
            }
            update();
        }

        // Initialize
        initThreeJS();
        update();
        animate();

        // Make functions globally available for HTML onclick handlers
        window.applyQualityMode = applyQualityMode;
        window.updateParamGroup = updateParamGroup;
        window.syncFromSlider = syncFromSlider;
        window.syncFromNumber = syncFromNumber;
        window.setView = setView;
    </script>
</body>
</html>
