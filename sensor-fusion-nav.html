<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sensor Fusion Navigation - SOUPY LABS</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg: #0a0a0f;
            --card: #12121a;
            --accent: #ffcd00;
            --text: #e0e0e0;
            --dim: #606080;
        }
        body {
            font-family: 'Roboto', sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            overflow-x: hidden;
        }
        .header {
            text-align: center;
            padding: 30px 20px;
            background: linear-gradient(135deg, rgba(255,205,0,0.1) 0%, transparent 100%);
            border-bottom: 1px solid rgba(255,205,0,0.2);
        }
        .header h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 2rem;
            color: var(--accent);
            text-shadow: 0 0 20px rgba(255,205,0,0.3);
            margin-bottom: 8px;
        }
        .header p { color: var(--dim); font-size: 0.9rem; }
        .back-link {
            position: absolute;
            top: 20px;
            left: 20px;
            color: var(--accent);
            text-decoration: none;
            font-size: 0.9rem;
            transition: opacity 0.3s;
        }
        .back-link:hover { opacity: 0.7; }
        .container {
            max-width: 1400px;
            margin: 20px auto;
            padding: 0 20px;
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
        }
        .controls {
            background: var(--card);
            border-radius: 10px;
            padding: 20px;
            border: 1px solid rgba(255,205,0,0.1);
            height: fit-content;
        }
        .control-group {
            margin-bottom: 20px;
        }
        .control-group label {
            display: block;
            color: var(--accent);
            font-size: 0.8rem;
            margin-bottom: 8px;
            font-weight: 500;
        }
        input[type="range"] {
            width: 100%;
            height: 6px;
            background: rgba(255,205,0,0.2);
            outline: none;
            border-radius: 3px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
        }
        .value-display {
            color: var(--text);
            font-size: 0.85rem;
            margin-top: 4px;
        }
        button {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, rgba(255,205,0,0.2), rgba(255,205,0,0.1));
            border: 1px solid var(--accent);
            color: var(--accent);
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.85rem;
            transition: all 0.3s;
            margin-top: 10px;
        }
        button:hover {
            background: linear-gradient(135deg, rgba(255,205,0,0.3), rgba(255,205,0,0.2));
            box-shadow: 0 0 20px rgba(255,205,0,0.2);
        }
        .simulation-area {
            background: var(--card);
            border-radius: 10px;
            padding: 20px;
            border: 1px solid rgba(255,205,0,0.1);
        }
        #canvas {
            width: 100%;
            height: 600px;
            background: #080810;
            border-radius: 8px;
            border: 1px solid rgba(255,205,0,0.1);
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .stat-card {
            background: rgba(255,205,0,0.05);
            border: 1px solid rgba(255,205,0,0.1);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
        }
        .stat-label {
            font-size: 0.7rem;
            color: var(--dim);
            margin-bottom: 4px;
        }
        .stat-value {
            font-size: 1.2rem;
            color: var(--accent);
            font-family: 'Orbitron', sans-serif;
        }
        .info-panel {
            background: rgba(255,205,0,0.05);
            border-left: 3px solid var(--accent);
            padding: 15px;
            margin-top: 20px;
            border-radius: 4px;
        }
        .info-panel h3 {
            color: var(--accent);
            font-size: 0.9rem;
            margin-bottom: 8px;
        }
        .info-panel p {
            font-size: 0.75rem;
            line-height: 1.5;
            color: var(--dim);
        }
        .legend {
            display: flex;
            gap: 15px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.75rem;
        }
        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }
        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to SOUPY LABS</a>

    <div class="header">
        <h1>üëÅÔ∏è SENSOR FUSION NAVIGATION</h1>
        <p>Visual SLAM and terrain-matching fused with INS for resilient navigation</p>
    </div>

    <div class="container">
        <div class="controls">
            <h3 style="color: var(--accent); margin-bottom: 15px; font-size: 1rem;">Control Panel</h3>

            <div class="control-group">
                <label>Camera Frame Rate (Hz)</label>
                <input type="range" id="camRate" min="10" max="60" value="30" step="5">
                <div class="value-display" id="camRateVal">30 Hz</div>
            </div>

            <div class="control-group">
                <label>Feature Detection Quality</label>
                <input type="range" id="featureQuality" min="1" max="10" value="7" step="1">
                <div class="value-display" id="featureQualityVal">7/10</div>
            </div>

            <div class="control-group">
                <label>IMU Drift Rate (m/s)</label>
                <input type="range" id="imuDrift" min="0" max="5" value="1" step="0.1">
                <div class="value-display" id="imuDriftVal">1.0 m/s</div>
            </div>

            <div class="control-group">
                <label>Terrain Matching Weight</label>
                <input type="range" id="terrainWeight" min="0" max="1" value="0.5" step="0.1">
                <div class="value-display" id="terrainWeightVal">0.5</div>
            </div>

            <div class="control-group">
                <label>Kalman Filter Q (Process)</label>
                <input type="range" id="kalmanQ" min="0.01" max="1" value="0.1" step="0.01">
                <div class="value-display" id="kalmanQVal">0.10</div>
            </div>

            <div class="control-group">
                <label>Kalman Filter R (Measurement)</label>
                <input type="range" id="kalmanR" min="0.01" max="1" value="0.2" step="0.01">
                <div class="value-display" id="kalmanRVal">0.20</div>
            </div>

            <div class="control-group">
                <label>Simulation Speed</label>
                <input type="range" id="simSpeed" min="0.1" max="5" value="1" step="0.1">
                <div class="value-display" id="simSpeedVal">1.0x</div>
            </div>

            <button id="resetBtn">üîÑ Reset Simulation</button>
            <button id="toggleSLAM">üì∑ Toggle SLAM</button>
            <button id="toggleTerrain">üóª Toggle Terrain Match</button>
            <button id="addObstacle">‚ûï Add Terrain Feature</button>
        </div>

        <div class="simulation-area">
            <canvas id="canvas" width="1000" height="600"></canvas>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-dot" style="background: #00ff9d;"></div>
                    <span>True Path</span>
                </div>
                <div class="legend-item">
                    <div class="legend-dot" style="background: #00aaff;"></div>
                    <span>INS (Dead Reckoning)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-dot" style="background: #ff6b35;"></div>
                    <span>Fused Estimate</span>
                </div>
                <div class="legend-item">
                    <div class="legend-dot" style="background: #ffcd00;"></div>
                    <span>SLAM Landmarks</span>
                </div>
                <div class="legend-item">
                    <div class="legend-dot" style="background: #aa00ff;"></div>
                    <span>Terrain Features</span>
                </div>
            </div>

            <div class="stats">
                <div class="stat-card">
                    <div class="stat-label">Position Error</div>
                    <div class="stat-value" id="posError">0.0 m</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">INS Drift</div>
                    <div class="stat-value" id="insDrift">0.0 m</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Landmarks Tracked</div>
                    <div class="stat-value" id="landmarks">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Fusion Confidence</div>
                    <div class="stat-value" id="confidence">100%</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Camera Updates</div>
                    <div class="stat-value" id="camUpdates">0</div>
                </div>
            </div>

            <div class="info-panel">
                <h3>About Sensor Fusion Navigation</h3>
                <p>
                    <strong>Sensor Fusion</strong> combines multiple sensor modalities to achieve robust navigation in GPS-denied
                    environments. This simulation demonstrates fusion of <strong>Visual SLAM</strong> (Simultaneous Localization and
                    Mapping using camera to track landmarks), <strong>Terrain Matching</strong> (correlating terrain features with
                    a database), and <strong>INS</strong> (inertial dead reckoning). A Kalman filter fuses these measurements,
                    weighting each by its uncertainty. Watch how the blue INS path drifts quadratically over time, while the red
                    fused estimate stays close to the green truth by correcting with visual landmarks (yellow) and terrain features
                    (purple). Toggle sensors on/off to see their individual contributions.
                </p>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // State
        let truePath = [];
        let insPath = [];
        let fusedPath = [];
        let landmarks = [];
        let terrainFeatures = [];
        let time = 0;
        let camUpdateCount = 0;

        // Positions
        let truePos = { x: 100, y: 300 };
        let trueVel = { x: 40, y: 0 };
        let trueHeading = 0;
        let insPos = { x: 100, y: 300 };
        let insVel = { x: 40, y: 0 };
        let fusedPos = { x: 100, y: 300 };

        // Kalman filter state
        let P = 1; // Estimate covariance

        // Flags
        let slamEnabled = true;
        let terrainEnabled = true;

        // Parameters
        let camRate = 30;
        let featureQuality = 7;
        let imuDrift = 1;
        let terrainWeight = 0.5;
        let kalmanQ = 0.1;
        let kalmanR = 0.2;
        let simSpeed = 1;

        // Initialize terrain features
        function initTerrain() {
            terrainFeatures = [];
            for (let i = 0; i < 15; i++) {
                terrainFeatures.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: 20 + Math.random() * 30
                });
            }
        }

        // Update controls
        document.getElementById('camRate').addEventListener('input', e => {
            camRate = parseFloat(e.target.value);
            document.getElementById('camRateVal').textContent = camRate + ' Hz';
        });
        document.getElementById('featureQuality').addEventListener('input', e => {
            featureQuality = parseFloat(e.target.value);
            document.getElementById('featureQualityVal').textContent = featureQuality + '/10';
        });
        document.getElementById('imuDrift').addEventListener('input', e => {
            imuDrift = parseFloat(e.target.value);
            document.getElementById('imuDriftVal').textContent = imuDrift.toFixed(1) + ' m/s';
        });
        document.getElementById('terrainWeight').addEventListener('input', e => {
            terrainWeight = parseFloat(e.target.value);
            document.getElementById('terrainWeightVal').textContent = terrainWeight.toFixed(1);
        });
        document.getElementById('kalmanQ').addEventListener('input', e => {
            kalmanQ = parseFloat(e.target.value);
            document.getElementById('kalmanQVal').textContent = kalmanQ.toFixed(2);
        });
        document.getElementById('kalmanR').addEventListener('input', e => {
            kalmanR = parseFloat(e.target.value);
            document.getElementById('kalmanRVal').textContent = kalmanR.toFixed(2);
        });
        document.getElementById('simSpeed').addEventListener('input', e => {
            simSpeed = parseFloat(e.target.value);
            document.getElementById('simSpeedVal').textContent = simSpeed.toFixed(1) + 'x';
        });

        document.getElementById('resetBtn').addEventListener('click', reset);
        document.getElementById('toggleSLAM').addEventListener('click', () => {
            slamEnabled = !slamEnabled;
            document.getElementById('toggleSLAM').textContent =
                slamEnabled ? 'üì∑ SLAM ON' : 'üì∑ SLAM OFF';
        });
        document.getElementById('toggleTerrain').addEventListener('click', () => {
            terrainEnabled = !terrainEnabled;
            document.getElementById('toggleTerrain').textContent =
                terrainEnabled ? 'üóª Terrain ON' : 'üóª Terrain OFF';
        });
        document.getElementById('addObstacle').addEventListener('click', () => {
            terrainFeatures.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: 20 + Math.random() * 30
            });
        });

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (canvas.width / rect.width);
            const y = (e.clientY - rect.top) * (canvas.height / rect.height);
            terrainFeatures.push({ x, y, size: 30 });
        });

        function reset() {
            truePath = [];
            insPath = [];
            fusedPath = [];
            landmarks = [];
            time = 0;
            camUpdateCount = 0;
            truePos = { x: 100, y: 300 };
            trueVel = { x: 40, y: 0 };
            trueHeading = 0;
            insPos = { x: 100, y: 300 };
            insVel = { x: 40, y: 0 };
            fusedPos = { x: 100, y: 300 };
            P = 1;
            initTerrain();
        }

        function gaussian(mean, stdDev) {
            let u1 = Math.random();
            let u2 = Math.random();
            let z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
            return mean + z0 * stdDev;
        }

        function detectLandmarks() {
            // Detect nearby terrain features as visual landmarks
            const detectionRange = 150;
            const detected = [];

            terrainFeatures.forEach(feature => {
                const dx = feature.x - truePos.x;
                const dy = feature.y - truePos.y;
                const dist = Math.sqrt(dx*dx + dy*dy);

                if (dist < detectionRange) {
                    // Add noise based on feature quality
                    const noise = (10 - featureQuality) * 2;
                    detected.push({
                        x: feature.x + gaussian(0, noise),
                        y: feature.y + gaussian(0, noise),
                        id: feature
                    });
                }
            });

            return detected;
        }

        function terrainMatch() {
            // Find closest terrain feature
            let minDist = Infinity;
            let closest = null;

            terrainFeatures.forEach(feature => {
                const dx = feature.x - fusedPos.x;
                const dy = feature.y - fusedPos.y;
                const dist = Math.sqrt(dx*dx + dy*dy);

                if (dist < minDist && dist < 200) {
                    minDist = dist;
                    closest = feature;
                }
            });

            return closest;
        }

        function kalmanUpdate(prediction, measurement, Q, R) {
            // Prediction update
            P = P + Q;

            // Measurement update
            const K = P / (P + R); // Kalman gain
            const estimate = prediction + K * (measurement - prediction);
            P = (1 - K) * P;

            return estimate;
        }

        function updateSimulation(dt) {
            // Update true motion
            trueHeading += 0.2 * dt * Math.sin(time * 0.3);
            const speed = 40;
            trueVel.x = speed * Math.cos(trueHeading);
            trueVel.y = speed * Math.sin(trueHeading);
            truePos.x += trueVel.x * dt;
            truePos.y += trueVel.y * dt;

            // Boundary wrap
            if (truePos.x < 0) truePos.x = canvas.width;
            if (truePos.x > canvas.width) truePos.x = 0;
            if (truePos.y < 0) truePos.y = canvas.height;
            if (truePos.y > canvas.height) truePos.y = 0;

            truePath.push({ ...truePos });
            if (truePath.length > 500) truePath.shift();

            // INS dead reckoning with drift
            const driftNoise = imuDrift * dt;
            insVel.x = trueVel.x + gaussian(0, driftNoise);
            insVel.y = trueVel.y + gaussian(0, driftNoise);
            insPos.x += insVel.x * dt;
            insPos.y += insVel.y * dt;

            insPath.push({ ...insPos });
            if (insPath.length > 500) insPath.shift();

            // Kalman filter prediction (use INS)
            let fusedX = fusedPos.x + insVel.x * dt;
            let fusedY = fusedPos.y + insVel.y * dt;

            // Camera update at camera frame rate
            if (time % (1 / camRate) < dt && slamEnabled) {
                const detectedLandmarks = detectLandmarks();
                landmarks = detectedLandmarks;
                camUpdateCount++;

                // Use landmarks to correct position
                if (detectedLandmarks.length > 0) {
                    let landmarkX = 0;
                    let landmarkY = 0;
                    detectedLandmarks.forEach(lm => {
                        landmarkX += lm.x;
                        landmarkY += lm.y;
                    });
                    landmarkX /= detectedLandmarks.length;
                    landmarkY /= detectedLandmarks.length;

                    // Kalman update with visual measurement
                    fusedX = kalmanUpdate(fusedX, landmarkX, kalmanQ, kalmanR);
                    fusedY = kalmanUpdate(fusedY, landmarkY, kalmanQ, kalmanR);
                }
            }

            // Terrain matching correction
            if (terrainEnabled) {
                const match = terrainMatch();
                if (match) {
                    fusedX = (1 - terrainWeight) * fusedX + terrainWeight * match.x;
                    fusedY = (1 - terrainWeight) * fusedY + terrainWeight * match.y;
                }
            }

            fusedPos.x = fusedX;
            fusedPos.y = fusedY;

            fusedPath.push({ ...fusedPos });
            if (fusedPath.length > 500) fusedPath.shift();

            time += dt;
        }

        function draw() {
            ctx.fillStyle = '#080810';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Grid
            ctx.strokeStyle = 'rgba(255,205,0,0.05)';
            ctx.lineWidth = 1;
            for (let x = 0; x < canvas.width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Terrain features
            ctx.fillStyle = 'rgba(170, 0, 255, 0.3)';
            ctx.strokeStyle = '#aa00ff';
            ctx.lineWidth = 2;
            terrainFeatures.forEach(f => {
                ctx.beginPath();
                ctx.arc(f.x, f.y, f.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            });

            // INS path (blue)
            ctx.strokeStyle = '#00aaff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            insPath.forEach((p, i) => {
                if (i === 0) ctx.moveTo(p.x, p.y);
                else ctx.lineTo(p.x, p.y);
            });
            ctx.stroke();

            // True path (green)
            ctx.strokeStyle = '#00ff9d';
            ctx.lineWidth = 2;
            ctx.beginPath();
            truePath.forEach((p, i) => {
                if (i === 0) ctx.moveTo(p.x, p.y);
                else ctx.lineTo(p.x, p.y);
            });
            ctx.stroke();

            // Fused path (red)
            ctx.strokeStyle = '#ff6b35';
            ctx.lineWidth = 3;
            ctx.beginPath();
            fusedPath.forEach((p, i) => {
                if (i === 0) ctx.moveTo(p.x, p.y);
                else ctx.lineTo(p.x, p.y);
            });
            ctx.stroke();

            // SLAM landmarks
            ctx.fillStyle = '#ffcd00';
            landmarks.forEach(lm => {
                ctx.beginPath();
                ctx.arc(lm.x, lm.y, 5, 0, Math.PI * 2);
                ctx.fill();

                // Line to vehicle
                ctx.strokeStyle = 'rgba(255,205,0,0.3)';
                ctx.beginPath();
                ctx.moveTo(truePos.x, truePos.y);
                ctx.lineTo(lm.x, lm.y);
                ctx.stroke();
            });

            // Current positions
            ctx.fillStyle = '#00ff9d';
            ctx.beginPath();
            ctx.arc(truePos.x, truePos.y, 10, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#00aaff';
            ctx.beginPath();
            ctx.arc(insPos.x, insPos.y, 8, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#ff6b35';
            ctx.beginPath();
            ctx.arc(fusedPos.x, fusedPos.y, 8, 0, Math.PI * 2);
            ctx.fill();

            // Update stats
            const posError = Math.sqrt((fusedPos.x - truePos.x)**2 + (fusedPos.y - truePos.y)**2);
            const insDrift = Math.sqrt((insPos.x - truePos.x)**2 + (insPos.y - truePos.y)**2);
            const confidence = Math.max(0, Math.min(100, 100 * (1 - P)));

            document.getElementById('posError').textContent = posError.toFixed(1) + ' m';
            document.getElementById('insDrift').textContent = insDrift.toFixed(1) + ' m';
            document.getElementById('landmarks').textContent = landmarks.length;
            document.getElementById('confidence').textContent = confidence.toFixed(0) + '%';
            document.getElementById('camUpdates').textContent = camUpdateCount;
        }

        function animate() {
            const dt = 0.02 * simSpeed;
            updateSimulation(dt);
            draw();
            requestAnimationFrame(animate);
        }

        reset();
        animate();
    </script>
</body>
</html>
