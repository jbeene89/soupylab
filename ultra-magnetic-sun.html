<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ultra Magnetic Sun Reactor v1.0 - 3D CGI</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap');

    * { margin: 0; padding: 0; box-sizing: border-box; }

    :root {
      --plasma-core: #ff6b35;
      --plasma-hot: #ffdd00;
      --plasma-cool: #00d4ff;
      --field-line: #00ff9d;
      --coil-active: #ff00ff;
      --coil-idle: #6600aa;
      --bg-deep: #030308;
      --bg-mid: #0a0a18;
      --panel-bg: rgba(10, 15, 30, 0.85);
      --text-glow: #00ffcc;
      --warning: #ff3366;
      --success: #00ff88;
    }

    body {
      font-family: 'Share Tech Mono', monospace;
      background: var(--bg-deep);
      color: #c0d0e0;
      min-height: 100vh;
      overflow-x: hidden;
    }

    .reactor-container {
      display: grid;
      grid-template-columns: 1fr 320px;
      grid-template-rows: auto 1fr auto;
      gap: 16px;
      padding: 16px;
      min-height: 100vh;
    }

    header {
      grid-column: 1 / -1;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 24px;
      background: var(--panel-bg);
      border: 1px solid rgba(0, 255, 157, 0.2);
      border-radius: 8px;
    }

    h1 {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.4rem;
      font-weight: 900;
      background: linear-gradient(90deg, var(--plasma-hot), var(--plasma-core), var(--coil-active));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 0 30px rgba(255, 107, 53, 0.5);
    }

    .status-badge {
      padding: 6px 16px;
      border-radius: 20px;
      font-size: 0.75rem;
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 2px;
      animation: pulse-glow 2s ease-in-out infinite;
    }

    .status-badge.nominal {
      background: rgba(0, 255, 136, 0.15);
      border: 1px solid var(--success);
      color: var(--success);
    }

    .status-badge.warning {
      background: rgba(255, 51, 102, 0.15);
      border: 1px solid var(--warning);
      color: var(--warning);
    }

    @keyframes pulse-glow {
      0%, 100% { box-shadow: 0 0 10px currentColor; }
      50% { box-shadow: 0 0 20px currentColor, 0 0 30px currentColor; }
    }

    .main-view {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .reactor-canvas-wrap {
      flex: 1;
      background: var(--panel-bg);
      border: 1px solid rgba(0, 255, 157, 0.2);
      border-radius: 12px;
      padding: 16px;
      position: relative;
      min-height: 500px;
    }

    #reactorContainer {
      width: 100%;
      height: 100%;
      border-radius: 8px;
    }

    .controls-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
    }

    .control-panel {
      background: var(--panel-bg);
      border: 1px solid rgba(0, 255, 157, 0.15);
      border-radius: 8px;
      padding: 16px;
    }

    .control-panel h3 {
      font-family: 'Orbitron', sans-serif;
      font-size: 0.7rem;
      color: var(--text-glow);
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .slider-group {
      margin-bottom: 12px;
    }

    .slider-group label {
      display: flex;
      justify-content: space-between;
      font-size: 0.75rem;
      margin-bottom: 4px;
      color: #8090a0;
    }

    .slider-group label span {
      color: var(--plasma-hot);
      font-weight: bold;
    }

    input[type="range"] {
      width: 100%;
      height: 6px;
      -webkit-appearance: none;
      background: linear-gradient(90deg, var(--plasma-cool), var(--plasma-core), var(--plasma-hot));
      border-radius: 3px;
      outline: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: #fff;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 10px var(--plasma-hot);
    }

    .btn {
      padding: 10px 20px;
      border: none;
      border-radius: 6px;
      font-family: 'Orbitron', sans-serif;
      font-size: 0.75rem;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 1px;
      transition: all 0.2s;
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--coil-active), var(--plasma-core));
      color: white;
    }

    .btn-primary:hover {
      box-shadow: 0 0 20px var(--coil-active);
      transform: translateY(-2px);
    }

    .btn-danger {
      background: linear-gradient(135deg, #ff3366, #cc0033);
      color: white;
    }

    .btn-success {
      background: linear-gradient(135deg, #00cc66, #009944);
      color: white;
    }

    .side-panel {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .psi-phi-panel {
      background: var(--panel-bg);
      border: 1px solid rgba(0, 255, 157, 0.2);
      border-radius: 12px;
      padding: 16px;
    }

    .psi-phi-panel h3 {
      font-family: 'Orbitron', sans-serif;
      font-size: 0.7rem;
      color: var(--coil-active);
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 2px;
      text-align: center;
    }

    #psiphiCanvas {
      width: 100%;
      aspect-ratio: 1;
      border-radius: 8px;
      background: radial-gradient(circle at center, #141429 0%, #050510 70%);
    }

    .metrics-panel {
      background: var(--panel-bg);
      border: 1px solid rgba(0, 255, 157, 0.15);
      border-radius: 8px;
      padding: 16px;
      flex: 1;
    }

    .metrics-panel h3 {
      font-family: 'Orbitron', sans-serif;
      font-size: 0.7rem;
      color: var(--text-glow);
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .metric {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      border-bottom: 1px solid rgba(255,255,255,0.05);
      font-size: 0.8rem;
    }

    .metric-label { color: #6080a0; }
    .metric-value {
      font-weight: bold;
      font-family: 'Orbitron', sans-serif;
    }

    .metric-value.hot { color: var(--plasma-hot); }
    .metric-value.cool { color: var(--plasma-cool); }
    .metric-value.good { color: var(--success); }
    .metric-value.warn { color: var(--warning); }

    .event-log {
      background: var(--panel-bg);
      border: 1px solid rgba(0, 255, 157, 0.15);
      border-radius: 8px;
      padding: 12px;
      max-height: 150px;
      overflow-y: auto;
    }

    .event-log h3 {
      font-family: 'Orbitron', sans-serif;
      font-size: 0.65rem;
      color: var(--text-glow);
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .log-entry {
      font-size: 0.7rem;
      padding: 4px 0;
      border-bottom: 1px solid rgba(255,255,255,0.03);
    }

    .log-entry.cme { color: var(--plasma-hot); }
    .log-entry.coil { color: var(--coil-active); }
    .log-entry.capture { color: var(--success); }
    .log-entry.warning { color: var(--warning); }

    footer {
      grid-column: 1 / -1;
      text-align: center;
      padding: 12px;
      font-size: 0.7rem;
      color: #405060;
    }

    ::-webkit-scrollbar { width: 6px; }
    ::-webkit-scrollbar-track { background: var(--bg-mid); }
    ::-webkit-scrollbar-thumb { background: var(--coil-idle); border-radius: 3px; }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.9);
      z-index: 1000;
      overflow-y: auto;
      padding: 40px;
    }
    .modal-content {
      max-width: 800px;
      margin: 0 auto;
      background: var(--panel-bg);
      border: 1px solid rgba(0,255,157,0.3);
      border-radius: 12px;
      padding: 32px;
    }
    .modal-close {
      float: right;
      background: none;
      border: none;
      color: #fff;
      font-size: 24px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div class="reactor-container">
    <header>
      <h1>‚öõ ULTRA MAGNETIC SUN REACTOR v1.0 - 3D CGI</h1>
      <div style="display: flex; align-items: center; gap: 16px;">
        <a href="index.html" style="color: var(--text-glow); text-decoration: none; font-size: 0.8rem; padding: 6px 12px; border: 1px solid rgba(0,255,157,0.3); border-radius: 4px;">‚Üê BACK</a>
        <button onclick="document.getElementById('docsModal').style.display='block'" style="color: var(--plasma-hot); background: none; border: 1px solid var(--plasma-hot); font-size: 0.8rem; padding: 6px 12px; border-radius: 4px; cursor: pointer;">üìÑ PHYSICS DOCS</button>
        <div class="status-badge nominal" id="statusBadge">NOMINAL</div>
      </div>
    </header>

    <div class="main-view">
      <div class="reactor-canvas-wrap">
        <div id="reactorContainer"></div>
      </div>

      <div class="controls-row">
        <div class="control-panel">
          <h3>Core Parameters</h3>
          <div class="slider-group">
            <label>Plasma Density <span id="densityVal">1.0</span>√ó10¬≤‚Å∞/m¬≥</label>
            <input type="range" id="plasmaDensity" min="0.1" max="3" step="0.1" value="1.0" oninput="updateParams()">
          </div>
          <div class="slider-group">
            <label>Core Temperature <span id="tempVal">150</span> MK</label>
            <input type="range" id="coreTemp" min="50" max="300" step="10" value="150" oninput="updateParams()">
          </div>
          <div class="slider-group">
            <label>Heating Power <span id="heatVal">50</span> MW</label>
            <input type="range" id="heatingPower" min="10" max="150" step="5" value="50" oninput="updateParams()">
          </div>
        </div>

        <div class="control-panel">
          <h3>Magnetic Systems</h3>
          <div class="slider-group">
            <label>Coil Field Strength <span id="fieldVal">5.0</span> T</label>
            <input type="range" id="fieldStrength" min="1" max="12" step="0.5" value="5" oninput="updateParams()">
          </div>
          <div class="slider-group">
            <label>Spring Damping <span id="dampVal">0.7</span></label>
            <input type="range" id="springDamping" min="0.1" max="1" step="0.05" value="0.7" oninput="updateParams()">
          </div>
          <div class="slider-group">
            <label>Rail Path Count <span id="railVal">6</span></label>
            <input type="range" id="railPaths" min="3" max="12" step="1" value="6" oninput="updateParams()">
          </div>
        </div>

        <div class="control-panel">
          <h3>Actions</h3>
          <div style="display: flex; gap: 8px; flex-wrap: wrap;">
            <button class="btn btn-primary" id="btnInjectCME">Inject CME</button>
            <button class="btn btn-success" id="btnStabilize">Auto-Stabilize</button>
            <button class="btn btn-danger" id="btnScram">SCRAM</button>
          </div>
        </div>
      </div>
    </div>

    <div class="side-panel">
      <div class="psi-phi-panel">
        <h3>Œ®Œ¶ Reactor Face</h3>
        <canvas id="psiphiCanvas" width="280" height="280"></canvas>
      </div>

      <div class="metrics-panel">
        <h3>Live Metrics</h3>
        <div class="metric">
          <span class="metric-label">Confinement Q</span>
          <span class="metric-value good" id="metricQ">1.2</span>
        </div>
        <div class="metric">
          <span class="metric-label">Lawson (nœÑT)</span>
          <span class="metric-value cool" id="metricLawson">2.1√ó10¬≤¬π</span>
        </div>
        <div class="metric">
          <span class="metric-label">Plasma Œ≤</span>
          <span class="metric-value" id="metricBeta">4.2%</span>
        </div>
        <div class="metric">
          <span class="metric-label">CME Captured</span>
          <span class="metric-value hot" id="metricCME">0 MJ</span>
        </div>
        <div class="metric">
          <span class="metric-label">Coil Displacement</span>
          <span class="metric-value" id="metricCoilDisp">0.0 cm</span>
        </div>
        <div class="metric">
          <span class="metric-label">Instability Index</span>
          <span class="metric-value good" id="metricInstab">0.12</span>
        </div>
      </div>

      <div class="event-log">
        <h3>Event Log</h3>
        <div id="logEntries"></div>
      </div>
    </div>

    <footer>
      SOUPY LAB MAXX ¬∑ Ultra Magnetic Sun Concept ¬∑ John Beene ¬∑ Glen St. Mary, FL
    </footer>

    <div id="docsModal" class="modal">
      <div class="modal-content">
        <button onclick="document.getElementById('docsModal').style.display='none'" class="modal-close">√ó</button>
        <h2 style="font-family:'Orbitron',sans-serif; color:var(--plasma-hot); margin-bottom:20px;">Ultra Magnetic Sun Reactor - Technical Overview</h2>

        <h3 style="color:var(--text-glow); margin-top:20px;">Core Concept</h3>
        <p style="color:#a0b0c0; line-height:1.7;">
          Unlike conventional tokamaks that force plasma into a toroidal geometry, or stellarators that use complex twisted coils for rotational transform, the Ultra Magnetic Sun maintains a <strong>spherical plasma core</strong> with external magnetic structures providing guidance rather than primary confinement.
        </p>

        <h3 style="color:var(--text-glow); margin-top:20px;">Key Innovations</h3>
        <ul style="color:#a0b0c0; line-height:1.8; padding-left:20px;">
          <li><strong>Spring-Mounted Coils:</strong> Superconducting magnets on mechanical dampers that move WITH plasma instabilities rather than fighting them electromagnetically. This converts MHD instability energy into mechanical motion.</li>
          <li><strong>Multi-Path Rail Network:</strong> Redundant magnetic pathways allow plasma to find lowest-energy configurations naturally, reducing disruption risk.</li>
          <li><strong>CME Capture Loops:</strong> Outer magnetic rings designed to intercept plasma ejections (analogous to solar CMEs) and convert them to induced current - turning instabilities into harvested energy.</li>
          <li><strong>Dynamic Coil Positioning:</strong> Real-time centroid tracking adjusts coil positions to maintain confinement without requiring massive field strength increases.</li>
        </ul>

        <h3 style="color:var(--text-glow); margin-top:20px;">Physics Parameters</h3>
        <ul style="color:#a0b0c0; line-height:1.8; padding-left:20px;">
          <li><strong>Lawson Criterion (nœÑT):</strong> Target >3√ó10¬≤¬π keV¬∑s/m¬≥ for D-T ignition</li>
          <li><strong>Plasma Œ≤:</strong> Ratio of plasma pressure to magnetic pressure - higher Œ≤ = more efficient confinement</li>
          <li><strong>Q Factor:</strong> Fusion power output / heating power input - Q>1 indicates net energy gain</li>
          <li><strong>Confinement Time (œÑ):</strong> Enhanced by spring-damped response to instabilities</li>
        </ul>

        <h3 style="color:var(--text-glow); margin-top:20px;">3D Visualization</h3>
        <p style="color:#a0b0c0; line-height:1.7;">
          This enhanced version uses Three.js WebGL rendering with 25,000+ GPU-accelerated particles, real-time 3D spring dynamics, and volumetric plasma visualization. All physics equations and calculations are preserved from the original design.
        </p>
      </div>
    </div>
  </div>

  <script>
    // ============================================
    // THREE.JS 3D ULTRA MAGNETIC SUN
    // ============================================

    let scene, camera, renderer;
    let plasmaSphere, plasmaGlow, plasmaParticles;
    let coilMeshes = [], springMeshes = [];
    let railLines = [];
    let fieldLines = [];
    let cmeGroups = [];
    let captureRing;

    const psiphiCanvas = document.getElementById('psiphiCanvas');
    const pctx = psiphiCanvas.getContext('2d');

    // State
    const state = {
      plasmaDensity: 1.0,
      coreTemp: 150,
      heatingPower: 50,
      fieldStrength: 5.0,
      springDamping: 0.7,
      railPaths: 6,

      plasmaOffset: new THREE.Vector3(0, 0, 0),
      plasmaVelocity: new THREE.Vector3(0, 0, 0),
      instability: 0.1,

      coils: [],
      numCoils: 8,

      cmes: [],
      cmesCaptured: 0,

      running: true,
      time: 0
    };

    // Init Three.js
    function init3D() {
      const container = document.getElementById('reactorContainer');

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x030308);
      scene.fog = new THREE.FogExp2(0x030308, 0.003);

      camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
      camera.position.set(15, 12, 15);
      camera.lookAt(0, 0, 0);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      container.appendChild(renderer.domElement);

      // Lighting
      const ambient = new THREE.AmbientLight(0x202040, 0.4);
      scene.add(ambient);

      const sun = new THREE.PointLight(0xff6633, 3, 100);
      sun.position.set(0, 15, 0);
      scene.add(sun);

      const fill = new THREE.PointLight(0x00aaff, 1.5, 80);
      fill.position.set(-10, 5, 10);
      scene.add(fill);

      const back = new THREE.PointLight(0xff00ff, 1, 60);
      back.position.set(0, -5, -15);
      scene.add(back);

      create3DPlasma();
      create3DCoils();
      create3DRails();
      create3DFieldLines();
      createCaptureRing();
    }

    // Create 3D Spherical Plasma
    function create3DPlasma() {
      // Main sphere
      const geometry = new THREE.SphereGeometry(3, 64, 64);
      const material = new THREE.MeshPhongMaterial({
        color: 0xff6633,
        emissive: 0xff3300,
        emissiveIntensity: 0.6,
        transparent: true,
        opacity: 0.8,
        shininess: 100
      });
      plasmaSphere = new THREE.Mesh(geometry, material);
      scene.add(plasmaSphere);

      // Outer glow
      const glowGeometry = new THREE.SphereGeometry(4, 32, 32);
      const glowMaterial = new THREE.MeshBasicMaterial({
        color: 0xffaa44,
        transparent: true,
        opacity: 0.2,
        side: THREE.BackSide
      });
      plasmaGlow = new THREE.Mesh(glowGeometry, glowMaterial);
      scene.add(plasmaGlow);

      // GPU Particles
      const particleCount = 25000;
      const positions = new Float32Array(particleCount * 3);
      const colors = new Float32Array(particleCount * 3);
      const sizes = new Float32Array(particleCount);

      for (let i = 0; i < particleCount; i++) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const r = 2.5 * Math.pow(Math.random(), 0.6);

        positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
        positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
        positions[i * 3 + 2] = r * Math.cos(phi);

        const temp = 1 - (r / 2.5);
        colors[i * 3] = 1.0;
        colors[i * 3 + 1] = 0.5 + temp * 0.5;
        colors[i * 3 + 2] = 0.1 + temp * 0.3;

        sizes[i] = 0.08 + Math.random() * 0.15;
      }

      const particleGeometry = new THREE.BufferGeometry();
      particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

      const particleMaterial = new THREE.PointsMaterial({
        size: 0.12,
        vertexColors: true,
        transparent: true,
        opacity: 0.9,
        blending: THREE.AdditiveBlending
      });

      plasmaParticles = new THREE.Points(particleGeometry, particleMaterial);
      scene.add(plasmaParticles);
    }

    // Create 3D Spring-Mounted Coils
    function create3DCoils() {
      state.coils = [];
      const baseRadius = 8;

      for (let i = 0; i < state.numCoils; i++) {
        const theta = (i / state.numCoils) * Math.PI * 2;
        const phi = Math.PI / 2;

        const coil = {
          theta,
          phi,
          baseRadius,
          currentRadius: baseRadius,
          targetRadius: baseRadius,
          velocity: 0,
          springK: 0.15,
          active: true
        };
        state.coils.push(coil);

        // Coil body (torus)
        const coilGeo = new THREE.TorusGeometry(0.6, 0.25, 16, 32);
        const coilMat = new THREE.MeshPhongMaterial({
          color: 0xff00ff,
          emissive: 0xaa0066,
          emissiveIntensity: 0.5,
          shininess: 80
        });
        const coilMesh = new THREE.Mesh(coilGeo, coilMat);

        const x = baseRadius * Math.sin(phi) * Math.cos(theta);
        const y = baseRadius * Math.cos(phi);
        const z = baseRadius * Math.sin(phi) * Math.sin(theta);
        coilMesh.position.set(x, y, z);
        coilMesh.lookAt(0, 0, 0);

        scene.add(coilMesh);
        coilMeshes.push(coilMesh);

        // Spring visualization (helix)
        const springCurve = new THREE.CatmullRomCurve3([
          new THREE.Vector3(x * 0.8, y * 0.8, z * 0.8),
          new THREE.Vector3(x, y, z)
        ]);
        const springGeo = new THREE.TubeGeometry(springCurve, 20, 0.08, 8, false);
        const springMat = new THREE.MeshPhongMaterial({
          color: 0x6666aa,
          transparent: true,
          opacity: 0.6
        });
        const springMesh = new THREE.Mesh(springGeo, springMat);
        scene.add(springMesh);
        springMeshes.push(springMesh);
      }
    }

    // Create 3D Rail Network
    function create3DRails() {
      railLines.forEach(line => scene.remove(line));
      railLines = [];

      const paths = state.railPaths;
      const innerR = 5;
      const outerR = 10;

      // Radial rails
      for (let p = 0; p < paths; p++) {
        const angle = (p / paths) * Math.PI * 2;
        const points = [
          new THREE.Vector3(innerR * Math.cos(angle), 0, innerR * Math.sin(angle)),
          new THREE.Vector3(outerR * Math.cos(angle), 0, outerR * Math.sin(angle))
        ];
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const material = new THREE.LineBasicMaterial({ color: 0x00ff9d, opacity: 0.3, transparent: true });
        const line = new THREE.Line(geometry, material);
        scene.add(line);
        railLines.push(line);
      }

      // Ring connections
      const innerPoints = [];
      const outerPoints = [];
      for (let i = 0; i <= paths; i++) {
        const angle = (i / paths) * Math.PI * 2;
        innerPoints.push(new THREE.Vector3(innerR * Math.cos(angle), 0, innerR * Math.sin(angle)));
        outerPoints.push(new THREE.Vector3(outerR * Math.cos(angle), 0, outerR * Math.sin(angle)));
      }

      const innerGeo = new THREE.BufferGeometry().setFromPoints(innerPoints);
      const innerLine = new THREE.Line(innerGeo, new THREE.LineBasicMaterial({ color: 0x00ff9d, opacity: 0.3, transparent: true }));
      scene.add(innerLine);
      railLines.push(innerLine);

      const outerGeo = new THREE.BufferGeometry().setFromPoints(outerPoints);
      const outerLine = new THREE.Line(outerGeo, new THREE.LineBasicMaterial({ color: 0x00ff9d, opacity: 0.3, transparent: true }));
      scene.add(outerLine);
      railLines.push(outerLine);
    }

    // Create 3D Magnetic Field Lines
    function create3DFieldLines() {
      for (let i = 0; i < 30; i++) {
        const theta = Math.random() * Math.PI * 2;
        const points = [];

        for (let j = 0; j <= 64; j++) {
          const t = j / 64;
          const r = 3 + t * 5;
          const angle = theta + t * Math.PI * 2;
          const y = (t - 0.5) * 8;

          points.push(new THREE.Vector3(
            r * Math.cos(angle),
            y,
            r * Math.sin(angle)
          ));
        }

        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const material = new THREE.LineBasicMaterial({ color: 0x00ffcc, opacity: 0.2, transparent: true });
        const line = new THREE.Line(geometry, material);
        scene.add(line);
        fieldLines.push(line);
      }
    }

    // Create CME Capture Ring
    function createCaptureRing() {
      const geometry = new THREE.TorusGeometry(10, 0.3, 16, 100);
      const material = new THREE.MeshPhongMaterial({
        color: 0xff6633,
        emissive: 0xff3300,
        emissiveIntensity: 0.3,
        transparent: true,
        opacity: 0.4
      });
      captureRing = new THREE.Mesh(geometry, material);
      scene.add(captureRing);
    }

    // Update Physics
    function updatePhysics(dt) {
      state.time += dt;

      // Plasma drift
      const driftForce = state.instability * 0.5;
      state.plasmaVelocity.x += (Math.random() - 0.5) * driftForce * dt;
      state.plasmaVelocity.y += (Math.random() - 0.5) * driftForce * dt;
      state.plasmaVelocity.z += (Math.random() - 0.5) * driftForce * dt;

      // Confinement from coils
      state.coils.forEach((coil, idx) => {
        const coilPos = coilMeshes[idx].position;
        const dir = new THREE.Vector3().subVectors(state.plasmaOffset, coilPos);
        const dist = dir.length();
        if (dist > 0.1) {
          const force = state.fieldStrength * 0.001 / (dist * dist);
          state.plasmaVelocity.sub(dir.normalize().multiplyScalar(force));
        }
      });

      state.plasmaVelocity.multiplyScalar(0.98);
      state.plasmaOffset.add(state.plasmaVelocity.clone().multiplyScalar(dt));

      // Update coil springs
      state.coils.forEach((coil, idx) => {
        const coilDir = new THREE.Vector3(
          Math.sin(coil.phi) * Math.cos(coil.theta),
          Math.cos(coil.phi),
          Math.sin(coil.phi) * Math.sin(coil.theta)
        );
        const projection = state.plasmaOffset.dot(coilDir);
        coil.targetRadius = coil.baseRadius + projection * 0.3;

        const springForce = (coil.targetRadius - coil.currentRadius) * coil.springK;
        coil.velocity += springForce;
        coil.velocity *= state.springDamping;
        coil.currentRadius += coil.velocity;

        // Update mesh position
        coilMeshes[idx].position.set(
          coil.currentRadius * Math.sin(coil.phi) * Math.cos(coil.theta),
          coil.currentRadius * Math.cos(coil.phi),
          coil.currentRadius * Math.sin(coil.phi) * Math.sin(coil.theta)
        );
        coilMeshes[idx].lookAt(0, 0, 0);
      });

      // Update plasma position
      plasmaSphere.position.copy(state.plasmaOffset);
      plasmaGlow.position.copy(state.plasmaOffset);
      plasmaParticles.position.copy(state.plasmaOffset);

      // Instability calculation
      const speed = state.plasmaVelocity.length();
      const offset = state.plasmaOffset.length();
      state.instability = Math.min(1, (speed * 10 + offset * 0.01) * (1 / state.fieldStrength));

      // Rotate particles
      plasmaParticles.rotation.y += 0.005 * (1 + state.instability);

      // Update CMEs
      state.cmes.forEach((cme, i) => {
        cme.mesh.position.addScaledVector(cme.direction, cme.speed * dt * 5);
        cme.radius += cme.speed * dt * 5;
        cme.alpha -= dt * 0.3;

        if (cme.radius > 9 && !cme.captured) {
          cme.captured = true;
          state.cmesCaptured += cme.energy;
          log(`CME captured: +${cme.energy.toFixed(1)} MJ`, 'capture');
        }
      });

      state.cmes = state.cmes.filter(cme => {
        if (cme.alpha <= 0) {
          scene.remove(cme.mesh);
          return false;
        }
        return true;
      });
    }

    // Inject CME (3D)
    function injectCME() {
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);
      const direction = new THREE.Vector3(
        Math.sin(phi) * Math.cos(theta),
        Math.sin(phi) * Math.sin(theta),
        Math.cos(phi)
      );

      const energy = 5 + Math.random() * 15;

      // Create CME particle cloud
      const particleCount = 1000;
      const positions = new Float32Array(particleCount * 3);
      const colors = new Float32Array(particleCount * 3);

      for (let i = 0; i < particleCount; i++) {
        const spread = 0.5;
        positions[i * 3] = (Math.random() - 0.5) * spread;
        positions[i * 3 + 1] = (Math.random() - 0.5) * spread;
        positions[i * 3 + 2] = (Math.random() - 0.5) * spread;

        colors[i * 3] = 1.0;
        colors[i * 3 + 1] = 0.5 + Math.random() * 0.5;
        colors[i * 3 + 2] = 0.1;
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

      const material = new THREE.PointsMaterial({
        size: 0.2,
        vertexColors: true,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending
      });

      const cmeMesh = new THREE.Points(geometry, material);
      cmeMesh.position.copy(state.plasmaOffset).addScaledVector(direction, 3);
      scene.add(cmeMesh);

      state.cmes.push({
        mesh: cmeMesh,
        direction,
        speed: 2 + Math.random() * 2,
        energy,
        alpha: 1,
        radius: 3,
        captured: false
      });

      state.plasmaVelocity.addScaledVector(direction, 0.3);
      state.instability = Math.min(1, state.instability + 0.3);

      log(`CME ejected! Energy: ${energy.toFixed(1)} MJ`, 'cme');
    }

    // Render PsiPhi Face
    function renderPsiPhiFace() {
      const W = psiphiCanvas.width;
      const H = psiphiCanvas.height;
      const cx = W / 2;
      const cy = H / 2;
      const R = 100;

      const coreTempNorm = state.coreTemp / 300;
      const confinementQuality = Math.max(0, 1 - state.instability);
      const flareActivity = state.cmes.length / 5;
      const instability = state.instability;

      const valence = confinementQuality * 2 - 1;
      const arousal = flareActivity * 2 - 1;
      const tension = instability * 2 - 1;

      const baseHue = 220 - coreTempNorm * 180;

      const mouthCurve = valence;
      const mouthOpen = Math.max(0, arousal);
      const eyeOpenness = 1.0 - tension * 0.5;
      const browRaise = -tension;

      pctx.clearRect(0, 0, W, H);

      // Background glow
      const fieldNoise = 0.05 + instability * 0.35;
      const glowRadius = R * (1.1 + 0.06 * Math.sin(state.time * 3 * 0.2));
      const grad = pctx.createRadialGradient(cx, cy, R * 0.2, cx, cy, glowRadius);
      const sat = 70 + 15 * arousal;
      const light = 40 + 10 * valence;

      grad.addColorStop(0, `hsla(${baseHue}, ${sat}%, ${light + 15}%, 0.9)`);
      grad.addColorStop(1, `hsla(${baseHue}, ${sat * 0.4}%, ${light - 10}%, 0.0)`);
      pctx.fillStyle = grad;
      pctx.beginPath();
      pctx.arc(cx, cy, glowRadius, 0, Math.PI * 2);
      pctx.fill();

      // Face circle
      pctx.fillStyle = `hsl(${baseHue}, ${sat}%, ${light + 5}%)`;
      pctx.beginPath();
      pctx.arc(cx, cy, R, 0, Math.PI * 2);
      pctx.fill();

      // Eyes
      const eyeOffsetX = 35;
      const eyeY = cy - 20;
      const eyeRadiusX = 14;
      const eyeRadiusY = 10 * eyeOpenness;

      function drawEye(ex, ey) {
        pctx.fillStyle = `hsla(${baseHue + 10}, 20%, 90%, 0.9)`;
        pctx.beginPath();
        pctx.ellipse(ex, ey, eyeRadiusX, Math.max(3, eyeRadiusY), 0, 0, Math.PI * 2);
        pctx.fill();

        const pupilR = 4 + 2 * Math.max(0, arousal);
        pctx.fillStyle = `hsl(${baseHue - 40}, 80%, 15%)`;
        pctx.beginPath();
        pctx.arc(ex, ey, pupilR, 0, Math.PI * 2);
        pctx.fill();
      }

      drawEye(cx - eyeOffsetX, eyeY);
      drawEye(cx + eyeOffsetX, eyeY);

      // Brows
      const browY = eyeY - 22 - browRaise * 6;
      function drawBrow(sign) {
        const startX = cx + sign * (eyeOffsetX - 16);
        const endX = cx + sign * (eyeOffsetX + 16);
        const tilt = browRaise * 8 * sign;
        pctx.strokeStyle = `hsl(${baseHue - 20}, 70%, 30%)`;
        pctx.lineWidth = 3;
        pctx.beginPath();
        pctx.moveTo(startX, browY + tilt);
        pctx.lineTo(endX, browY - tilt);
        pctx.stroke();
      }
      drawBrow(-1);
      drawBrow(1);

      // Mouth
      const mouthY = cy + 35;
      const mouthWidth = 50;
      const curve = mouthCurve * 20;
      const open = mouthOpen * 15;

      pctx.strokeStyle = `hsl(${baseHue - 10}, 80%, 25%)`;
      pctx.lineWidth = 4;
      pctx.beginPath();
      pctx.moveTo(cx - mouthWidth, mouthY);
      pctx.quadraticCurveTo(cx, mouthY + curve - open, cx + mouthWidth, mouthY);
      pctx.stroke();

      if (mouthOpen > 0.1) {
        pctx.fillStyle = `hsl(${baseHue - 20}, 80%, 15%)`;
        pctx.beginPath();
        pctx.moveTo(cx - mouthWidth, mouthY);
        pctx.quadraticCurveTo(cx, mouthY + curve - open, cx + mouthWidth, mouthY);
        pctx.lineTo(cx + mouthWidth, mouthY + 4 + open);
        pctx.lineTo(cx - mouthWidth, mouthY + 4 + open);
        pctx.closePath();
        pctx.fill();
      }
    }

    // Update Metrics
    function updateMetrics() {
      const n = state.plasmaDensity * 1e20;
      const T = state.coreTemp * 1e6;
      const tau = state.fieldStrength * 0.5 * (1 - state.instability);
      const nTauT = n * tau * T;

      const Q = (state.heatingPower > 0) ?
        (state.coreTemp * state.plasmaDensity * (1 - state.instability)) / (state.heatingPower * 0.5) : 0;

      const beta = (state.plasmaDensity * state.coreTemp) / (state.fieldStrength * state.fieldStrength) * 2;

      const maxCoilDisp = Math.max(...state.coils.map(c => Math.abs(c.currentRadius - c.baseRadius)));

      document.getElementById('metricQ').textContent = Q.toFixed(2);
      document.getElementById('metricQ').className = 'metric-value ' + (Q > 1 ? 'good' : Q > 0.5 ? '' : 'warn');

      document.getElementById('metricLawson').textContent = (nTauT / 1e21).toFixed(1) + '√ó10¬≤¬π';
      document.getElementById('metricBeta').textContent = beta.toFixed(1) + '%';
      document.getElementById('metricCME').textContent = state.cmesCaptured.toFixed(1) + ' MJ';
      document.getElementById('metricCoilDisp').textContent = maxCoilDisp.toFixed(1) + ' cm';

      document.getElementById('metricInstab').textContent = state.instability.toFixed(2);
      document.getElementById('metricInstab').className = 'metric-value ' +
        (state.instability < 0.3 ? 'good' : state.instability < 0.6 ? '' : 'warn');

      const badge = document.getElementById('statusBadge');
      if (state.instability > 0.7) {
        badge.textContent = 'UNSTABLE';
        badge.className = 'status-badge warning';
      } else if (Q > 1) {
        badge.textContent = 'IGNITION';
        badge.className = 'status-badge nominal';
      } else {
        badge.textContent = 'NOMINAL';
        badge.className = 'status-badge nominal';
      }
    }

    // Event Log
    const logEntries = document.getElementById('logEntries');
    function log(msg, type = '') {
      const entry = document.createElement('div');
      entry.className = 'log-entry ' + type;
      entry.textContent = `[${state.time.toFixed(1)}s] ${msg}`;
      logEntries.insertBefore(entry, logEntries.firstChild);
      if (logEntries.children.length > 50) {
        logEntries.removeChild(logEntries.lastChild);
      }
    }

    // Update Parameters
    function updateParams() {
      state.plasmaDensity = parseFloat(document.getElementById('plasmaDensity').value);
      state.coreTemp = parseFloat(document.getElementById('coreTemp').value);
      state.heatingPower = parseFloat(document.getElementById('heatingPower').value);
      state.fieldStrength = parseFloat(document.getElementById('fieldStrength').value);
      state.springDamping = parseFloat(document.getElementById('springDamping').value);
      state.railPaths = parseInt(document.getElementById('railPaths').value);

      document.getElementById('densityVal').textContent = state.plasmaDensity.toFixed(1);
      document.getElementById('tempVal').textContent = state.coreTemp;
      document.getElementById('heatVal').textContent = state.heatingPower;
      document.getElementById('fieldVal').textContent = state.fieldStrength.toFixed(1);
      document.getElementById('dampVal').textContent = state.springDamping.toFixed(2);
      document.getElementById('railVal').textContent = state.railPaths;

      // Update plasma scale based on temperature
      const scale = 1 + (state.coreTemp / 300) * 0.3;
      plasmaSphere.scale.set(scale, scale, scale);

      create3DRails();
    }

    // Controls
    document.getElementById('btnInjectCME').addEventListener('click', injectCME);

    document.getElementById('btnStabilize').addEventListener('click', () => {
      log('Auto-stabilization engaged', 'coil');
      state.plasmaVelocity.set(0, 0, 0);
      state.plasmaOffset.multiplyScalar(0.5);
      state.coils.forEach(c => {
        c.velocity = 0;
        c.currentRadius = c.baseRadius;
      });
    });

    document.getElementById('btnScram').addEventListener('click', () => {
      log('SCRAM initiated - emergency shutdown', 'warning');
      state.running = false;
      state.coreTemp = 50;
      state.heatingPower = 0;
      state.instability = 0;
      document.getElementById('coreTemp').value = 50;
      document.getElementById('heatingPower').value = 0;
      updateParams();

      setTimeout(() => {
        state.running = true;
        log('Reactor restart available', 'coil');
      }, 2000);
    });

    // Random CME events
    setInterval(() => {
      if (state.running && state.coreTemp > 100 && Math.random() < 0.15 * (state.instability + 0.1)) {
        injectCME();
      }
    }, 3000);

    // Main Loop
    let lastTime = performance.now();

    function mainLoop() {
      const now = performance.now();
      const dt = Math.min((now - lastTime) / 1000, 0.05);
      lastTime = now;

      if (state.running) {
        updatePhysics(dt);
      }

      // Auto-rotate camera
      camera.position.x = 15 * Math.cos(state.time * 0.1);
      camera.position.z = 15 * Math.sin(state.time * 0.1);
      camera.lookAt(0, 0, 0);

      renderPsiPhiFace();
      updateMetrics();

      renderer.render(scene, camera);
      requestAnimationFrame(mainLoop);
    }

    // Handle Resize
    window.addEventListener('resize', () => {
      const container = document.getElementById('reactorContainer');
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    });

    // Initialize
    window.addEventListener('load', () => {
      init3D();
      log('Ultra Magnetic Sun Reactor initialized', 'coil');
      log('Spring-mounted coils online', 'coil');
      log('CME capture loops armed', 'capture');
      log('3D CGI visualization active', 'coil');
      mainLoop();
    });
  </script>
</body>
</html>
