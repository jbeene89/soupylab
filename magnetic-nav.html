<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magnetic Anomaly Navigation - SOUPY LABS</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg: #0a0a0f;
            --card: #12121a;
            --accent: #ffcd00;
            --text: #e0e0e0;
            --dim: #606080;
        }
        body {
            font-family: 'Roboto', sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            overflow-x: hidden;
        }
        .header {
            text-align: center;
            padding: 30px 20px;
            background: linear-gradient(135deg, rgba(255,205,0,0.1) 0%, transparent 100%);
            border-bottom: 1px solid rgba(255,205,0,0.2);
        }
        .header h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 2rem;
            color: var(--accent);
            text-shadow: 0 0 20px rgba(255,205,0,0.3);
            margin-bottom: 8px;
        }
        .header p { color: var(--dim); font-size: 0.9rem; }
        .back-link {
            position: absolute;
            top: 20px;
            left: 20px;
            color: var(--accent);
            text-decoration: none;
            font-size: 0.9rem;
            transition: opacity 0.3s;
        }
        .back-link:hover { opacity: 0.7; }
        .container {
            max-width: 1400px;
            margin: 20px auto;
            padding: 0 20px;
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
        }
        .controls {
            background: var(--card);
            border-radius: 10px;
            padding: 20px;
            border: 1px solid rgba(255,205,0,0.1);
            height: fit-content;
        }
        .control-group {
            margin-bottom: 20px;
        }
        .control-group label {
            display: block;
            color: var(--accent);
            font-size: 0.8rem;
            margin-bottom: 8px;
            font-weight: 500;
        }
        input[type="range"] {
            width: 100%;
            height: 6px;
            background: rgba(255,205,0,0.2);
            outline: none;
            border-radius: 3px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
        }
        .value-display {
            color: var(--text);
            font-size: 0.85rem;
            margin-top: 4px;
        }
        button {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, rgba(255,205,0,0.2), rgba(255,205,0,0.1));
            border: 1px solid var(--accent);
            color: var(--accent);
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.85rem;
            transition: all 0.3s;
            margin-top: 10px;
        }
        button:hover {
            background: linear-gradient(135deg, rgba(255,205,0,0.3), rgba(255,205,0,0.2));
            box-shadow: 0 0 20px rgba(255,205,0,0.2);
        }
        .simulation-area {
            background: var(--card);
            border-radius: 10px;
            padding: 20px;
            border: 1px solid rgba(255,205,0,0.1);
        }
        #canvas {
            width: 100%;
            height: 600px;
            background: #080810;
            border-radius: 8px;
            border: 1px solid rgba(255,205,0,0.1);
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .stat-card {
            background: rgba(255,205,0,0.05);
            border: 1px solid rgba(255,205,0,0.1);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
        }
        .stat-label {
            font-size: 0.7rem;
            color: var(--dim);
            margin-bottom: 4px;
        }
        .stat-value {
            font-size: 1.2rem;
            color: var(--accent);
            font-family: 'Orbitron', sans-serif;
        }
        .info-panel {
            background: rgba(255,205,0,0.05);
            border-left: 3px solid var(--accent);
            padding: 15px;
            margin-top: 20px;
            border-radius: 4px;
        }
        .info-panel h3 {
            color: var(--accent);
            font-size: 0.9rem;
            margin-bottom: 8px;
        }
        .info-panel p {
            font-size: 0.75rem;
            line-height: 1.5;
            color: var(--dim);
        }
        .legend {
            display: flex;
            gap: 15px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.75rem;
        }
        .legend-color {
            width: 20px;
            height: 12px;
            border-radius: 2px;
        }
        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to SOUPY LABS</a>

    <div class="header">
        <h1>üß≤ MAGNETIC ANOMALY NAVIGATION</h1>
        <p>Map-matching using Earth's magnetic field for GPS-denied positioning</p>
    </div>

    <div class="container">
        <div class="controls">
            <h3 style="color: var(--accent); margin-bottom: 15px; font-size: 1rem;">Control Panel</h3>

            <div class="control-group">
                <label>Vehicle Speed (m/s)</label>
                <input type="range" id="speed" min="5" max="100" value="30" step="1">
                <div class="value-display" id="speedVal">30 m/s</div>
            </div>

            <div class="control-group">
                <label>Magnetometer Noise (nT)</label>
                <input type="range" id="magNoise" min="0" max="100" value="20" step="5">
                <div class="value-display" id="magNoiseVal">20 nT</div>
            </div>

            <div class="control-group">
                <label>Map Resolution (m)</label>
                <input type="range" id="mapRes" min="10" max="100" value="50" step="10">
                <div class="value-display" id="mapResVal">50 m</div>
            </div>

            <div class="control-group">
                <label>Correlation Window (samples)</label>
                <input type="range" id="corrWindow" min="5" max="50" value="20" step="5">
                <div class="value-display" id="corrWindowVal">20</div>
            </div>

            <div class="control-group">
                <label>Terrain Variance</label>
                <input type="range" id="variance" min="1" max="10" value="5" step="1">
                <div class="value-display" id="varianceVal">5</div>
            </div>

            <div class="control-group">
                <label>Simulation Speed</label>
                <input type="range" id="simSpeed" min="0.1" max="5" value="1" step="0.1">
                <div class="value-display" id="simSpeedVal">1.0x</div>
            </div>

            <button id="resetBtn">üîÑ Reset Simulation</button>
            <button id="toggleMap">üó∫Ô∏è Toggle Map Display</button>
            <button id="randomPath">üé≤ Random Flight Path</button>
        </div>

        <div class="simulation-area">
            <canvas id="canvas" width="1000" height="600"></canvas>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: linear-gradient(to right, blue, cyan, green, yellow, red);"></div>
                    <span>Magnetic Field Intensity</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #00ff9d;"></div>
                    <span>True Path</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff6b35;"></div>
                    <span>Estimated Position</span>
                </div>
            </div>

            <div class="stats">
                <div class="stat-card">
                    <div class="stat-label">Position Error</div>
                    <div class="stat-value" id="posError">0.0 m</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Correlation Score</div>
                    <div class="stat-value" id="correlation">0.00</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Current Field</div>
                    <div class="stat-value" id="currentField">45000 nT</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Distance Traveled</div>
                    <div class="stat-value" id="distance">0 km</div>
                </div>
            </div>

            <div class="info-panel">
                <h3>About Magnetic Anomaly Navigation (MagNav)</h3>
                <p>
                    <strong>MagNav</strong> is a passive GPS-denied navigation technique that compares real-time magnetometer
                    measurements to a pre-stored magnetic anomaly map. The Earth's magnetic field varies spatially due to
                    geological features (iron deposits, crustal variations). By measuring the local field and correlating
                    the readings with the map using algorithms like cross-correlation or particle filters, a vehicle can
                    estimate its position. This simulation shows a vehicle (green trail) flying over a synthetic magnetic
                    anomaly field (colored background). The red marker shows the estimated position from MagNav correlation.
                    Watch how noise and map resolution affect positioning accuracy.
                </p>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Magnetic anomaly map (2D field)
        const mapWidth = canvas.width / 5;
        const mapHeight = canvas.height / 5;
        let magMap = [];
        let showMap = true;

        // Vehicle state
        let truePos = { x: 100, y: 300 };
        let estPos = { x: 100, y: 300 };
        let velocity = { x: 30, y: 0 };
        let truePath = [];
        let measurements = [];
        let time = 0;
        let totalDistance = 0;

        // Parameters
        let speed = 30;
        let magNoise = 20;
        let mapRes = 50;
        let corrWindow = 20;
        let variance = 5;
        let simSpeed = 1;

        // Generate synthetic magnetic anomaly map using Perlin-like noise
        function generateMagMap() {
            magMap = [];
            for (let y = 0; y < mapHeight; y++) {
                magMap[y] = [];
                for (let x = 0; x < mapWidth; x++) {
                    let value = 0;
                    // Multi-octave noise
                    for (let octave = 1; octave <= 4; octave++) {
                        const freq = octave * 0.05;
                        const amp = variance * 5000 / octave;
                        value += amp * (Math.sin(x * freq) * Math.cos(y * freq) +
                                       Math.sin((x + 37) * freq * 1.3) * Math.cos((y + 23) * freq * 0.7));
                    }
                    magMap[y][x] = 45000 + value; // Base field ~45000 nT
                }
            }
        }

        function getMagField(x, y) {
            const mapX = Math.floor(x / 5);
            const mapY = Math.floor(y / 5);
            if (mapX >= 0 && mapX < mapWidth && mapY >= 0 && mapY < mapHeight) {
                return magMap[mapY][mapX];
            }
            return 45000;
        }

        function gaussian(mean, stdDev) {
            let u1 = Math.random();
            let u2 = Math.random();
            let z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
            return mean + z0 * stdDev;
        }

        // Cross-correlation for position estimation
        function estimatePosition() {
            if (measurements.length < corrWindow) {
                return truePos;
            }

            let bestScore = -Infinity;
            let bestPos = { ...truePos };

            // Search grid around current estimate
            const searchRadius = 100;
            const step = mapRes;

            for (let dy = -searchRadius; dy <= searchRadius; dy += step) {
                for (let dx = -searchRadius; dx <= searchRadius; dx += step) {
                    const testX = estPos.x + dx;
                    const testY = estPos.y + dy;

                    // Calculate correlation score
                    let score = 0;
                    const recentMeasurements = measurements.slice(-corrWindow);
                    for (let i = 0; i < recentMeasurements.length; i++) {
                        const m = recentMeasurements[i];
                        const backtrackX = testX - (corrWindow - i) * velocity.x * 0.1;
                        const backtrackY = testY - (corrWindow - i) * velocity.y * 0.1;
                        const mapValue = getMagField(backtrackX, backtrackY);
                        score -= Math.abs(m - mapValue); // Negative MAE
                    }

                    if (score > bestScore) {
                        bestScore = score;
                        bestPos = { x: testX, y: testY };
                    }
                }
            }

            return bestPos;
        }

        // Update controls
        document.getElementById('speed').addEventListener('input', e => {
            speed = parseFloat(e.target.value);
            document.getElementById('speedVal').textContent = speed + ' m/s';
        });
        document.getElementById('magNoise').addEventListener('input', e => {
            magNoise = parseFloat(e.target.value);
            document.getElementById('magNoiseVal').textContent = magNoise + ' nT';
        });
        document.getElementById('mapRes').addEventListener('input', e => {
            mapRes = parseFloat(e.target.value);
            document.getElementById('mapResVal').textContent = mapRes + ' m';
        });
        document.getElementById('corrWindow').addEventListener('input', e => {
            corrWindow = parseInt(e.target.value);
            document.getElementById('corrWindowVal').textContent = corrWindow;
        });
        document.getElementById('variance').addEventListener('input', e => {
            variance = parseFloat(e.target.value);
            document.getElementById('varianceVal').textContent = variance;
            generateMagMap();
        });
        document.getElementById('simSpeed').addEventListener('input', e => {
            simSpeed = parseFloat(e.target.value);
            document.getElementById('simSpeedVal').textContent = simSpeed.toFixed(1) + 'x';
        });

        document.getElementById('resetBtn').addEventListener('click', reset);
        document.getElementById('toggleMap').addEventListener('click', () => {
            showMap = !showMap;
        });
        document.getElementById('randomPath').addEventListener('click', () => {
            const angle = Math.random() * Math.PI * 2;
            velocity.x = speed * Math.cos(angle);
            velocity.y = speed * Math.sin(angle);
        });

        function reset() {
            truePos = { x: 100, y: 300 };
            estPos = { x: 100, y: 300 };
            const angle = Math.random() * Math.PI * 2;
            velocity.x = speed * Math.cos(angle);
            velocity.y = speed * Math.sin(angle);
            truePath = [];
            measurements = [];
            time = 0;
            totalDistance = 0;
            generateMagMap();
        }

        function updateSimulation(dt) {
            // Update true position
            truePos.x += velocity.x * dt;
            truePos.y += velocity.y * dt;

            // Boundary wrap
            if (truePos.x < 0) truePos.x = canvas.width;
            if (truePos.x > canvas.width) truePos.x = 0;
            if (truePos.y < 0) truePos.y = canvas.height;
            if (truePos.y > canvas.height) truePos.y = 0;

            truePath.push({ ...truePos });
            if (truePath.length > 1000) truePath.shift();

            // Measure magnetic field with noise
            const trueField = getMagField(truePos.x, truePos.y);
            const measuredField = trueField + gaussian(0, magNoise);
            measurements.push(measuredField);
            if (measurements.length > corrWindow * 2) measurements.shift();

            // Estimate position using correlation
            if (measurements.length >= corrWindow) {
                estPos = estimatePosition();
            }

            totalDistance += Math.sqrt(velocity.x**2 + velocity.y**2) * dt / 1000; // km
            time += dt;
        }

        function drawMagMap() {
            if (!showMap) return;

            for (let y = 0; y < mapHeight; y++) {
                for (let x = 0; x < mapWidth; x++) {
                    const value = magMap[y][x];
                    const normalized = (value - 40000) / 10000; // Normalize for color
                    const hue = Math.max(0, Math.min(240, 240 * (1 - normalized)));
                    ctx.fillStyle = `hsl(${hue}, 80%, 40%)`;
                    ctx.fillRect(x * 5, y * 5, 5, 5);
                }
            }
        }

        function draw() {
            ctx.fillStyle = '#080810';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw magnetic anomaly map
            drawMagMap();

            // True path (green)
            ctx.strokeStyle = '#00ff9d';
            ctx.lineWidth = 2;
            ctx.beginPath();
            truePath.forEach((p, i) => {
                if (i === 0) ctx.moveTo(p.x, p.y);
                else ctx.lineTo(p.x, p.y);
            });
            ctx.stroke();

            // True position
            ctx.fillStyle = '#00ff9d';
            ctx.beginPath();
            ctx.arc(truePos.x, truePos.y, 8, 0, Math.PI * 2);
            ctx.fill();

            // Estimated position
            ctx.fillStyle = '#ff6b35';
            ctx.strokeStyle = '#ff6b35';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(estPos.x, estPos.y, 12, 0, Math.PI * 2);
            ctx.stroke();

            // Line connecting true and estimated
            ctx.strokeStyle = 'rgba(255,107,53,0.3)';
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(truePos.x, truePos.y);
            ctx.lineTo(estPos.x, estPos.y);
            ctx.stroke();
            ctx.setLineDash([]);

            // Update stats
            const posError = Math.sqrt((estPos.x - truePos.x)**2 + (estPos.y - truePos.y)**2);
            const currentField = measurements.length > 0 ? measurements[measurements.length - 1] : 45000;

            // Calculate correlation coefficient
            let correlation = 0;
            if (measurements.length >= corrWindow) {
                const recent = measurements.slice(-corrWindow);
                const mean = recent.reduce((a, b) => a + b, 0) / recent.length;
                const std = Math.sqrt(recent.reduce((a, b) => a + (b - mean)**2, 0) / recent.length);
                correlation = std > 0 ? 1 - (posError / 100) : 0; // Simplified
            }

            document.getElementById('posError').textContent = posError.toFixed(1) + ' m';
            document.getElementById('correlation').textContent = Math.max(0, Math.min(1, correlation)).toFixed(2);
            document.getElementById('currentField').textContent = currentField.toFixed(0) + ' nT';
            document.getElementById('distance').textContent = totalDistance.toFixed(1) + ' km';
        }

        function animate() {
            const dt = 0.1 * simSpeed;
            updateSimulation(dt);
            draw();
            requestAnimationFrame(animate);
        }

        reset();
        animate();
    </script>
</body>
</html>
