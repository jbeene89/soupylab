<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PIC Plasma Simulator - Soupy Labs</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg: #0a0a0f;
            --panel: #12121a;
            --accent: #00ff9d;
            --electron: #00aaff;
            --ion: #ff6644;
            --text: #e0e0e0;
            --dim: #606080;
        }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--bg);
            color: var(--text);
            height: 100vh;
            overflow: hidden;
        }
        header {
            background: linear-gradient(180deg, rgba(0,170,255,0.1) 0%, transparent 100%);
            border-bottom: 1px solid rgba(0,170,255,0.2);
            padding: 12px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        header h1 { font-size: 1.2rem; color: var(--electron); }
        header a {
            color: var(--accent);
            text-decoration: none;
            padding: 6px 12px;
            border: 1px solid rgba(0,255,157,0.3);
            border-radius: 4px;
            font-size: 0.8rem;
        }
        .container {
            display: grid;
            grid-template-columns: 300px 1fr;
            height: calc(100vh - 56px);
        }
        .controls {
            background: var(--panel);
            padding: 16px;
            overflow-y: auto;
            border-right: 1px solid rgba(255,255,255,0.05);
        }
        .section { margin-bottom: 20px; }
        .section h3 {
            font-size: 0.8rem;
            color: var(--accent);
            margin-bottom: 12px;
            padding-bottom: 6px;
            border-bottom: 1px solid rgba(0,255,157,0.2);
        }
        .slider-row { margin-bottom: 12px; }
        .slider-row label {
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            color: var(--dim);
            margin-bottom: 4px;
        }
        .slider-row label span { color: var(--accent); font-family: monospace; }
        .slider-input-row {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        .slider-input-row input[type="range"] {
            flex: 1;
            height: 4px;
            -webkit-appearance: none;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
        }
        .slider-input-row input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px; height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
        }
        .slider-input-row input[type="number"] {
            width: 70px;
            background: rgba(0,0,0,0.4);
            border: 1px solid rgba(255,255,255,0.15);
            color: var(--accent);
            padding: 4px 6px;
            border-radius: 4px;
            font-size: 0.7rem;
            font-family: monospace;
            text-align: right;
        }
        .checkbox-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            font-size: 0.75rem;
        }
        .preset-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }
        .preset-btn {
            padding: 10px 6px;
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 4px;
            color: var(--text);
            font-size: 0.65rem;
            cursor: pointer;
        }
        .preset-btn:hover { border-color: var(--electron); }
        .preset-btn.active { border-color: var(--electron); background: rgba(0,170,255,0.2); }
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 12px;
        }
        .stat-box {
            background: rgba(0,0,0,0.3);
            padding: 8px;
            border-radius: 4px;
            text-align: center;
        }
        .stat-box .label { font-size: 0.6rem; color: var(--dim); }
        .stat-box .value { font-size: 0.85rem; font-family: monospace; color: var(--accent); }
        .legend {
            display: flex;
            gap: 16px;
            margin-top: 12px;
            font-size: 0.7rem;
        }
        .legend-item { display: flex; align-items: center; gap: 6px; }
        .legend-dot { width: 10px; height: 10px; border-radius: 50%; }
        .electron-dot { background: var(--electron); }
        .ion-dot { background: var(--ion); }
        .btn-action {
            width: 100%;
            padding: 10px;
            background: linear-gradient(135deg, var(--electron), #0066cc);
            border: none;
            border-radius: 6px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            margin-top: 8px;
        }

        .canvas-area { position: relative; background: #000; }
        #scene-container { width: 100%; height: 100%; }

        .info-overlay {
            position: absolute;
            top: 16px;
            left: 16px;
            background: rgba(0,0,0,0.8);
            padding: 12px;
            border-radius: 8px;
            font-size: 0.7rem;
            border: 1px solid var(--electron);
            z-index: 10;
        }
        .info-overlay h4 { color: var(--electron); margin-bottom: 6px; }

        .camera-controls {
            position: absolute;
            top: 16px;
            right: 16px;
            display: flex;
            gap: 8px;
            z-index: 10;
        }
        .camera-btn {
            background: rgba(0,170,255,0.3);
            border: 1px solid var(--electron);
            color: var(--text);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.7rem;
            cursor: pointer;
            backdrop-filter: blur(10px);
        }
        .camera-btn.active {
            background: var(--electron);
            color: #000;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <header>
        <h1>⚡ PARTICLE-IN-CELL PLASMA</h1>
        <a href="index.html">← BACK TO LAB</a>
    </header>

    <div class="container">
        <div class="controls">
            <div class="section">
                <h3>CONFIGURATION</h3>
                <div class="preset-buttons">
                    <button class="preset-btn active" onclick="setPreset('gyration')">Gyration</button>
                    <button class="preset-btn" onclick="setPreset('mirror')">Mirror Trap</button>
                    <button class="preset-btn" onclick="setPreset('drift')">E×B Drift</button>
                    <button class="preset-btn" onclick="setPreset('plasma')">Thermal</button>
                </div>
            </div>

            <div class="section">
                <h3>PARTICLES</h3>
                <div class="slider-row">
                    <label>Electrons <span id="neVal">5000</span></label>
                    <div class="slider-input-row">
                        <input type="range" id="ne" min="100" max="20000" step="100" value="5000" oninput="syncSlider('ne')">
                        <input type="number" id="ne_num" min="100" max="20000" step="100" value="5000" onchange="syncNumber('ne')">
                    </div>
                </div>
                <div class="slider-row">
                    <label>Ions <span id="niVal">1000</span></label>
                    <div class="slider-input-row">
                        <input type="range" id="ni" min="0" max="5000" step="100" value="1000" oninput="syncSlider('ni')">
                        <input type="number" id="ni_num" min="0" max="5000" step="100" value="1000" onchange="syncNumber('ni')">
                    </div>
                </div>
                <div class="slider-row">
                    <label>Temperature (eV) <span id="tempVal">10</span></label>
                    <div class="slider-input-row">
                        <input type="range" id="temp" min="1" max="100" value="10" oninput="syncSlider('temp')">
                        <input type="number" id="temp_num" min="1" max="100" value="10" onchange="syncNumber('temp')">
                    </div>
                </div>
            </div>

            <div class="section">
                <h3>FIELDS</h3>
                <div class="slider-row">
                    <label>B-field (T) <span id="bVal">1.0</span></label>
                    <div class="slider-input-row">
                        <input type="range" id="bfield" min="0" max="5" step="0.1" value="1" oninput="syncSlider('bfield')">
                        <input type="number" id="bfield_num" min="0" max="5" step="0.1" value="1" onchange="syncNumber('bfield')">
                    </div>
                </div>
                <div class="slider-row">
                    <label>E-field (kV/m) <span id="eVal">0</span></label>
                    <div class="slider-input-row">
                        <input type="range" id="efield" min="-30" max="30" value="0" oninput="syncSlider('efield')">
                        <input type="number" id="efield_num" min="-30" max="30" value="0" onchange="syncNumber('efield')">
                    </div>
                </div>
                <div class="slider-row">
                    <label>Mirror Ratio <span id="mirrorVal">1.0</span></label>
                    <div class="slider-input-row">
                        <input type="range" id="mirror" min="1" max="4" step="0.1" value="1" oninput="syncSlider('mirror')">
                        <input type="number" id="mirror_num" min="1" max="4" step="0.1" value="1" onchange="syncNumber('mirror')">
                    </div>
                </div>
            </div>

            <div class="section">
                <h3>DISPLAY</h3>
                <div class="checkbox-row">
                    <input type="checkbox" id="showTrails" checked onchange="updateParams()">
                    <label for="showTrails">Show Trails</label>
                </div>
                <div class="checkbox-row">
                    <input type="checkbox" id="showField" checked onchange="updateParams()">
                    <label for="showField">Show B-Field Lines</label>
                </div>
                <div class="checkbox-row">
                    <input type="checkbox" id="showBox" checked onchange="updateParams()">
                    <label for="showBox">Show Confinement Box</label>
                </div>
            </div>

            <button class="btn-action" onclick="resetSim()">↺ RESET SIMULATION</button>

            <div class="legend">
                <div class="legend-item"><div class="legend-dot electron-dot"></div> e⁻</div>
                <div class="legend-item"><div class="legend-dot ion-dot"></div> ions</div>
            </div>

            <div class="stats-grid">
                <div class="stat-box">
                    <div class="label">Gyro Radius</div>
                    <div class="value" id="gyroR">--</div>
                </div>
                <div class="stat-box">
                    <div class="label">Gyro Freq</div>
                    <div class="value" id="gyroF">--</div>
                </div>
                <div class="stat-box">
                    <div class="label">Total Particles</div>
                    <div class="value" id="totalP">--</div>
                </div>
                <div class="stat-box">
                    <div class="label">Avg Velocity</div>
                    <div class="value" id="avgV">--</div>
                </div>
            </div>
        </div>

        <div class="canvas-area">
            <div id="scene-container"></div>
            <div class="info-overlay">
                <h4>3D PARTICLE-IN-CELL</h4>
                <div>Boris pusher algorithm</div>
                <div style="margin-top: 6px; color: var(--accent);">
                    GPU-accelerated • 20k particles
                </div>
            </div>
            <div class="camera-controls">
                <button class="camera-btn active" onclick="setCamera('perspective')">Perspective</button>
                <button class="camera-btn" onclick="setCamera('side')">Side</button>
                <button class="camera-btn" onclick="setCamera('top')">Top</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Physics constants
        const e = 1.6e-19, me = 9.1e-31, mi = 1.67e-27;

        // THREE.JS Setup
        let scene, camera, renderer;
        let electronSystem, ionSystem;
        let fieldLines = [];
        let confinementBox;
        let time = 0;

        const params = {
            ne: 5000, ni: 1000, temp: 10,
            B: 1.0, E: 0, mirror: 1.0,
            showTrails: true, showField: true, showBox: true
        };

        const scale = 100; // Visual scale
        const boxSize = 200;

        // Particle data arrays
        let electronData = {
            positions: null, velocities: null, colors: null, count: 0
        };
        let ionData = {
            positions: null, velocities: null, colors: null, count: 0
        };

        function initThreeJS() {
            const container = document.getElementById('scene-container');

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            scene.fog = new THREE.Fog(0x000000, 100, 500);

            // Camera
            camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(250, 150, 250);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const pointLight1 = new THREE.PointLight(0x00aaff, 1.5, 400);
            pointLight1.position.set(150, 100, 150);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0xff6644, 1.2, 400);
            pointLight2.position.set(-150, 100, -150);
            scene.add(pointLight2);

            // Create confinement box
            createConfinementBox();

            // Create field lines
            createFieldLines();

            // Initialize particles
            initParticles();

            // Mouse controls
            setupMouseControls();

            // Handle resize
            window.addEventListener('resize', onWindowResize);

            // Start animation
            animate();
        }

        function createConfinementBox() {
            const geometry = new THREE.BoxGeometry(boxSize, boxSize, boxSize);
            const edges = new THREE.EdgesGeometry(geometry);
            const material = new THREE.LineBasicMaterial({
                color: 0x00ff9d,
                transparent: true,
                opacity: 0.3
            });
            confinementBox = new THREE.LineSegments(edges, material);
            scene.add(confinementBox);
        }

        function createFieldLines() {
            // Clear old field lines
            fieldLines.forEach(line => scene.remove(line));
            fieldLines = [];

            if (!params.showField) return;

            const numLines = 12;
            const lineLength = boxSize * 1.2;

            for (let i = 0; i < numLines; i++) {
                const angle = (i / numLines) * Math.PI * 2;
                const radius = boxSize * 0.4;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;

                const points = [];
                const segments = 50;

                for (let j = 0; j < segments; j++) {
                    const z = (j / segments - 0.5) * lineLength;

                    // Mirror field variation
                    const zn = z / (boxSize / 2);
                    const mirrorFactor = 1 + (params.mirror - 1) * zn * zn;
                    const r = radius / Math.sqrt(mirrorFactor);

                    const px = Math.cos(angle) * r;
                    const py = Math.sin(angle) * r;
                    points.push(new THREE.Vector3(px, py, z));
                }

                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({
                    color: 0x00aaff,
                    transparent: true,
                    opacity: 0.4
                });

                const line = new THREE.Line(geometry, material);
                fieldLines.push(line);
                scene.add(line);
            }
        }

        function initParticles() {
            // Remove old particle systems
            if (electronSystem) scene.remove(electronSystem);
            if (ionSystem) scene.remove(ionSystem);

            const vth_e = Math.sqrt(2 * params.temp * e / me);
            const vth_i = Math.sqrt(2 * params.temp * e / mi);

            // Initialize electron data
            electronData.count = params.ne;
            electronData.positions = new Float32Array(params.ne * 3);
            electronData.velocities = new Float32Array(params.ne * 3);
            electronData.colors = new Float32Array(params.ne * 3);

            for (let i = 0; i < params.ne; i++) {
                electronData.positions[i * 3] = (Math.random() - 0.5) * boxSize * 0.8;
                electronData.positions[i * 3 + 1] = (Math.random() - 0.5) * boxSize * 0.8;
                electronData.positions[i * 3 + 2] = (Math.random() - 0.5) * boxSize * 0.8;

                electronData.velocities[i * 3] = (Math.random() - 0.5) * vth_e * 1e-4;
                electronData.velocities[i * 3 + 1] = (Math.random() - 0.5) * vth_e * 1e-4;
                electronData.velocities[i * 3 + 2] = (Math.random() - 0.5) * vth_e * 1e-4;

                const color = new THREE.Color(0x00aaff);
                electronData.colors[i * 3] = color.r;
                electronData.colors[i * 3 + 1] = color.g;
                electronData.colors[i * 3 + 2] = color.b;
            }

            const electronGeometry = new THREE.BufferGeometry();
            electronGeometry.setAttribute('position', new THREE.BufferAttribute(electronData.positions, 3));
            electronGeometry.setAttribute('color', new THREE.BufferAttribute(electronData.colors, 3));

            const electronMaterial = new THREE.PointsMaterial({
                size: 2,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });

            electronSystem = new THREE.Points(electronGeometry, electronMaterial);
            scene.add(electronSystem);

            // Initialize ion data
            ionData.count = params.ni;
            ionData.positions = new Float32Array(params.ni * 3);
            ionData.velocities = new Float32Array(params.ni * 3);
            ionData.colors = new Float32Array(params.ni * 3);

            for (let i = 0; i < params.ni; i++) {
                ionData.positions[i * 3] = (Math.random() - 0.5) * boxSize * 0.8;
                ionData.positions[i * 3 + 1] = (Math.random() - 0.5) * boxSize * 0.8;
                ionData.positions[i * 3 + 2] = (Math.random() - 0.5) * boxSize * 0.8;

                ionData.velocities[i * 3] = (Math.random() - 0.5) * vth_i * 1e-4;
                ionData.velocities[i * 3 + 1] = (Math.random() - 0.5) * vth_i * 1e-4;
                ionData.velocities[i * 3 + 2] = (Math.random() - 0.5) * vth_i * 1e-4;

                const color = new THREE.Color(0xff6644);
                ionData.colors[i * 3] = color.r;
                ionData.colors[i * 3 + 1] = color.g;
                ionData.colors[i * 3 + 2] = color.b;
            }

            const ionGeometry = new THREE.BufferGeometry();
            ionGeometry.setAttribute('position', new THREE.BufferAttribute(ionData.positions, 3));
            ionGeometry.setAttribute('color', new THREE.BufferAttribute(ionData.colors, 3));

            const ionMaterial = new THREE.PointsMaterial({
                size: 3.5,
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });

            ionSystem = new THREE.Points(ionGeometry, ionMaterial);
            scene.add(ionSystem);

            updateStats();
        }

        function getField(x, y, z) {
            // Magnetic field (B) along z-axis with mirror configuration
            const zn = z / (boxSize / 2);
            const Bz = params.B * (1 + (params.mirror - 1) * zn * zn);

            // Electric field (E) perpendicular to B
            const Ex = params.E * 1000;
            const Ey = 0;
            const Ez = 0;

            return { Ex, Ey, Ez, Bx: 0, By: 0, Bz };
        }

        function borisPush(data, dt, charge, mass) {
            const qm = charge / mass;
            const h = dt * 0.5;

            for (let i = 0; i < data.count; i++) {
                const x = data.positions[i * 3];
                const y = data.positions[i * 3 + 1];
                const z = data.positions[i * 3 + 2];

                let vx = data.velocities[i * 3];
                let vy = data.velocities[i * 3 + 1];
                let vz = data.velocities[i * 3 + 2];

                const field = getField(x, y, z);

                // Half electric impulse
                let vxm = vx + qm * field.Ex * h;
                let vym = vy + qm * field.Ey * h;
                let vzm = vz + qm * field.Ez * h;

                // Magnetic rotation
                const tx = qm * field.Bx * h;
                const ty = qm * field.By * h;
                const tz = qm * field.Bz * h;
                const t2 = tx * tx + ty * ty + tz * tz;
                const sx = 2 * tx / (1 + t2);
                const sy = 2 * ty / (1 + t2);
                const sz = 2 * tz / (1 + t2);

                const vpx = vxm + vym * tz - vzm * ty;
                const vpy = vym + vzm * tx - vxm * tz;
                const vpz = vzm + vxm * ty - vym * tx;

                const vxp = vxm + vpy * sz - vpz * sy;
                const vyp = vym + vpz * sx - vpx * sz;
                const vzp = vzm + vpx * sy - vpy * sx;

                // Half electric impulse
                vx = vxp + qm * field.Ex * h;
                vy = vyp + qm * field.Ey * h;
                vz = vzp + qm * field.Ez * h;

                // Update position
                data.positions[i * 3] += vx * dt;
                data.positions[i * 3 + 1] += vy * dt;
                data.positions[i * 3 + 2] += vz * dt;

                // Update velocity
                data.velocities[i * 3] = vx;
                data.velocities[i * 3 + 1] = vy;
                data.velocities[i * 3 + 2] = vz;

                // Boundary conditions (reflective)
                const limit = boxSize / 2;
                if (Math.abs(data.positions[i * 3]) > limit) {
                    data.positions[i * 3] = Math.sign(data.positions[i * 3]) * limit;
                    data.velocities[i * 3] *= -0.9;
                }
                if (Math.abs(data.positions[i * 3 + 1]) > limit) {
                    data.positions[i * 3 + 1] = Math.sign(data.positions[i * 3 + 1]) * limit;
                    data.velocities[i * 3 + 1] *= -0.9;
                }
                if (Math.abs(data.positions[i * 3 + 2]) > limit) {
                    data.positions[i * 3 + 2] = Math.sign(data.positions[i * 3 + 2]) * limit;
                    data.velocities[i * 3 + 2] *= -0.9;
                }
            }
        }

        function updateParticles() {
            const dt = 1e-11; // Time step

            // Update electrons
            borisPush(electronData, dt, -e, me);
            if (electronSystem) {
                electronSystem.geometry.attributes.position.needsUpdate = true;
            }

            // Update ions
            borisPush(ionData, dt, e, mi);
            if (ionSystem) {
                ionSystem.geometry.attributes.position.needsUpdate = true;
            }
        }

        // Mouse controls
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let rotation = { x: 0.4, y: 0.8 };

        function setupMouseControls() {
            const container = document.getElementById('scene-container');

            container.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            container.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;

                    rotation.y += deltaX * 0.005;
                    rotation.x += deltaY * 0.005;
                    rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotation.x));

                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });

            container.addEventListener('mouseup', () => {
                isDragging = false;
            });

            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                const distance = camera.position.length();
                const newDistance = distance + e.deltaY * 0.5;
                const clampedDistance = Math.max(150, Math.min(600, newDistance));
                camera.position.multiplyScalar(clampedDistance / distance);
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;

            // Update camera rotation
            if (!isDragging) {
                rotation.y += 0.003;
            }

            const distance = camera.position.length();
            camera.position.x = distance * Math.sin(rotation.y) * Math.cos(rotation.x);
            camera.position.y = distance * Math.sin(rotation.x);
            camera.position.z = distance * Math.cos(rotation.y) * Math.cos(rotation.x);
            camera.lookAt(0, 0, 0);

            // Update particles
            updateParticles();

            // Animate field lines
            fieldLines.forEach((line, i) => {
                line.material.opacity = 0.3 + Math.sin(time * 3 + i * 0.5) * 0.1;
            });

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            const container = document.getElementById('scene-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function setCamera(view) {
            document.querySelectorAll('.camera-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            isDragging = false;

            switch(view) {
                case 'perspective':
                    rotation = { x: 0.4, y: 0.8 };
                    break;
                case 'side':
                    rotation = { x: 0, y: Math.PI / 2 };
                    break;
                case 'top':
                    rotation = { x: Math.PI / 2 - 0.1, y: 0 };
                    break;
            }
        }

        // === UI CONTROLS ===
        function syncSlider(id) {
            const slider = document.getElementById(id);
            const numInput = document.getElementById(id + '_num');
            if (numInput) numInput.value = slider.value;
            updateParams();
        }

        function syncNumber(id) {
            const numInput = document.getElementById(id + '_num');
            const slider = document.getElementById(id);
            if (slider) {
                let val = parseFloat(numInput.value);
                val = Math.max(parseFloat(slider.min), Math.min(parseFloat(slider.max), val));
                slider.value = val;
                numInput.value = val;
            }
            updateParams();
        }

        function updateParams() {
            const oldNe = params.ne;
            const oldNi = params.ni;

            params.ne = +document.getElementById('ne').value;
            params.ni = +document.getElementById('ni').value;
            params.temp = +document.getElementById('temp').value;
            params.B = +document.getElementById('bfield').value;
            params.E = +document.getElementById('efield').value;
            params.mirror = +document.getElementById('mirror').value;
            params.showTrails = document.getElementById('showTrails').checked;
            params.showField = document.getElementById('showField').checked;
            params.showBox = document.getElementById('showBox').checked;

            document.getElementById('neVal').textContent = params.ne;
            document.getElementById('niVal').textContent = params.ni;
            document.getElementById('tempVal').textContent = params.temp;
            document.getElementById('bVal').textContent = params.B.toFixed(1);
            document.getElementById('eVal').textContent = params.E;
            document.getElementById('mirrorVal').textContent = params.mirror.toFixed(1);

            // Rebuild particles if count changed
            if (oldNe !== params.ne || oldNi !== params.ni) {
                initParticles();
            }

            // Update field lines if mirror changed
            if (params.showField) {
                createFieldLines();
            } else {
                fieldLines.forEach(line => scene.remove(line));
                fieldLines = [];
            }

            // Update confinement box visibility
            if (confinementBox) {
                confinementBox.visible = params.showBox;
            }

            updateStats();
        }

        function updateStats() {
            const vth = Math.sqrt(2 * params.temp * e / me);
            const rL = params.B > 0 ? (me * vth) / (e * params.B) : 0;
            const wc = params.B > 0 ? (e * params.B) / me : 0;

            document.getElementById('gyroR').textContent = (rL * 1e6).toFixed(1) + ' μm';
            document.getElementById('gyroF').textContent = (wc / 1e9).toFixed(1) + ' GHz';
            document.getElementById('totalP').textContent = (params.ne + params.ni).toLocaleString();
            document.getElementById('avgV').textContent = (vth / 1e6).toFixed(1) + ' Mm/s';
        }

        function setPreset(name) {
            document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');

            if (name === 'gyration') {
                params.ne = 100; params.ni = 10; params.B = 2; params.E = 0; params.mirror = 1; params.temp = 10;
            } else if (name === 'mirror') {
                params.ne = 3000; params.ni = 500; params.B = 2; params.E = 0; params.mirror = 3; params.temp = 15;
            } else if (name === 'drift') {
                params.ne = 5000; params.ni = 1000; params.B = 2; params.E = 15; params.mirror = 1; params.temp = 10;
            } else if (name === 'plasma') {
                params.ne = 10000; params.ni = 2000; params.B = 1; params.E = 0; params.mirror = 1; params.temp = 20;
            }

            updateSliders();
            initParticles();
        }

        function updateSliders() {
            document.getElementById('ne').value = params.ne;
            document.getElementById('ne_num').value = params.ne;
            document.getElementById('ni').value = params.ni;
            document.getElementById('ni_num').value = params.ni;
            document.getElementById('temp').value = params.temp;
            document.getElementById('temp_num').value = params.temp;
            document.getElementById('bfield').value = params.B;
            document.getElementById('bfield_num').value = params.B;
            document.getElementById('efield').value = params.E;
            document.getElementById('efield_num').value = params.E;
            document.getElementById('mirror').value = params.mirror;
            document.getElementById('mirror_num').value = params.mirror;
            updateParams();
        }

        function resetSim() {
            initParticles();
        }

        // Initialize on load
        window.addEventListener('load', () => {
            initThreeJS();
            updateParams();
        });
    </script>
</body>
</html>
